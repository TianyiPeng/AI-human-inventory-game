<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Mode B - Weekly Feedback with OR+LLM</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.6/dist/chart.umd.min.js"></script>
  <style>
    :root {
      --primary: #667eea;
      --primary-dark: #5568d3;
      --accent: #764ba2;
      --success: #27ae60;
      --surface: #ffffff;
      --surface-muted: #f7f8ff;
      --border-radius: 10px;
      --shadow: 0 6px 16px rgba(40, 51, 117, 0.12);
      --text-muted: #666666;
      --text-subtle: #9095a7;
    }
    * {
      box-sizing: border-box;
    }
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #eef1ff 0%, #f7e9ff 100%);
      color: #1f2440;
    }
    header {
      background: var(--primary);
      color: var(--surface);
      padding: 20px;
      text-align: center;
      box-shadow: 0 4px 14px rgba(0, 0, 0, 0.15);
    }
    header h1 {
      margin: 0;
      font-size: 28px;
      letter-spacing: 0.3px;
    }
    header p {
      margin: 8px 0 0;
      font-size: 15px;
      opacity: 0.9;
    }
    main {
      max-width: 1260px;
      margin: 0 auto;
      padding: 28px 24px 48px;
      display: flex;
      flex-direction: column;
      gap: 24px;
    }
    .panel {
      background: var(--surface);
      border-radius: var(--border-radius);
      box-shadow: var(--shadow);
      padding: 24px 26px;
    }
    .panel h2,
    .panel h3,
    .panel h4 {
      margin: 0;
      font-weight: 600;
    }
    .panel:not(:last-child) {
      margin-bottom: 4px;
    }
    label {
      display: block;
      margin-bottom: 10px;
      font-weight: 500;
    }
    .input-label {
      font-weight: 600;
      color: #2f3458;
    }
    input,
    textarea,
    button,
    select {
      width: 100%;
      padding: 12px;
      margin-top: 6px;
      border: 1px solid #d7daf1;
      border-radius: 8px;
      font-size: 14px;
      font-family: inherit;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
      background: #fbfbff;
    }
    input:focus,
    textarea:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
      background: #ffffff;
    }
    textarea {
      min-height: 100px;
      resize: vertical;
    }
    button {
      background: var(--primary);
      color: #ffffff;
      border: none;
      cursor: pointer;
      font-weight: 600;
      letter-spacing: 0.3px;
      transition: background 0.25s ease, transform 0.2s ease;
    }
    button:hover:not(:disabled) {
      background: var(--primary-dark);
      transform: translateY(-1px);
    }
    button:disabled {
      background: #c8cdea;
      cursor: not-allowed;
    }
    button.ghost {
      width: auto;
      padding: 8px 18px;
      background: transparent;
      color: var(--primary);
      border: 1px solid var(--primary);
      border-radius: 999px;
      font-size: 13px;
    }
    button.ghost:disabled {
      color: #aeb4d9;
      border-color: #ccd1f4;
      background: transparent;
    }
    .game-layout {
      display: flex;
      flex-wrap: nowrap;
      gap: 28px;
      align-items: stretch;
    }
    .column {
      flex: 1 1 360px;
      display: flex;
      flex-direction: column;
      gap: 24px;
      min-width: 320px;
      min-height: 100%;
    }
    .column-left {
      display: flex;
      flex-direction: column;
      gap: 24px;
    }
    .column-right {
      display: flex;
      flex-direction: column;
      gap: 24px;
    }
    .right-bottom-wrapper {
      display: flex;
      flex-direction: column;
      gap: 16px;
      flex: 1 1 auto;
      min-height: 0;
    }
    .news-section {
      background: #f6f7ff;
      border-radius: 12px;
      padding: 18px 20px;
      border: 1px solid #dfe2ff;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.65);
      display: flex;
      flex-direction: column;
      gap: 16px;
      flex: 0 0 230px;
      max-height: 240px;
      min-height: 220px;
      overflow: hidden;
    }
    .news-header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 12px;
    }
    .news-header h3 {
      margin: 0;
      font-size: 18px;
      color: #2e3460;
    }
    .news-header span {
      font-size: 13px;
      color: var(--text-subtle);
    }
    .news-columns {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      flex: 1 1 auto;
      align-content: start;
      overflow-y: auto;
      padding-right: 6px;
    }
    .news-column {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .news-column h4 {
      margin: 0;
      font-size: 14px;
      color: #494f78;
      letter-spacing: 0.4px;
      text-transform: uppercase;
    }
    .news-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
      flex: 1 1 auto;
    }
    .news-list .placeholder {
      padding: 18px 0;
    }
    .history-panel {
      background: #f1f3ff;
      border-radius: 12px;
      border: 1px solid #d5daf9;
      padding: 18px 20px;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.6);
      flex: 0 0 auto;
      min-height: 260px;
      display: flex;
      flex-direction: column;
      gap: 14px;
    }
    .history-panel h3 {
      margin: 0;
      font-size: 17px;
      color: #2b2f53;
    }
    .history-list {
      flex: 1 1 auto;
      min-height: 0;
      overflow-y: auto;
      padding-right: 6px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .history-entry {
      background: rgba(255, 255, 255, 0.75);
      border-radius: 10px;
      border: 1px solid rgba(102, 126, 234, 0.25);
      padding: 12px 14px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .history-entry header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 8px;
      font-weight: 600;
      color: #343a6f;
      font-size: 14px;
    }
    .history-entry header span {
      font-size: 12px;
      color: #2f3158;
      font-weight: 500;
    }
    .history-body {
      background: #fff;
      border-radius: 8px;
      border: 1px dashed rgba(102, 126, 234, 0.25);
      padding: 12px 14px;
      font-family: 'Segoe UI', Arial, sans-serif;
      font-size: 15px;
      color: #2f3158;
      white-space: pre-wrap;
      line-height: 1.7;
    }
    .history-placeholder {
      color: var(--text-subtle);
      font-style: italic;
      font-size: 14px;
    }
    .snapshot-panel {
      padding: 22px 24px;
      display: flex;
      flex-direction: column;
      gap: 18px;
    }
    .snapshot-title {
      font-size: 18px;
      font-weight: 600;
      color: #242949;
      margin: 0 0 12px 0;
    }
    .snapshot-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    .snapshot-box {
      background: var(--surface-muted);
      border-radius: 10px;
      padding: 16px 18px;
      border: 1px solid #dfe2ff;
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-height: 70px;
    }
    .snapshot-label {
      font-size: 13px;
      color: #5f6275;
      font-weight: 500;
    }
    .snapshot-value {
      font-size: 20px;
      font-weight: 700;
      color: #161937;
    }
    .snapshot-subtext {
      font-size: 11px;
      color: #8a9099;
      font-style: italic;
      margin-top: 4px;
    }
    .snapshot-cost-info {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 13px;
      color: #5f6275;
      margin-top: 8px;
    }
    .snapshot-cost-info span {
      font-weight: 600;
      color: #2d3255;
    }
    .product-info {
      background: linear-gradient(135deg, #f8f9ff 0%, #f1f3ff 100%);
      border-radius: 12px;
      padding: 24px;
      border: 1px solid #e1e6ff;
      display: flex;
      align-items: center;
      gap: 24px;
    }
    .product-image-container {
      flex-shrink: 0;
    }
    .product-image-container img {
      width: 150px;
      height: 150px;
      object-fit: contain;
      border-radius: 8px;
      background: #ffffff;
      padding: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      border: 1px solid #e1e6ff;
    }
    .product-text {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .product-name {
      font-size: 18px;
      font-weight: 700;
      color: #161937;
      margin: 0;
    }
    .product-description-text {
      font-size: 14px;
      color: #5f6275;
      line-height: 1.6;
      margin: 0;
    }
    @media (max-width: 768px) {
      .product-info {
        flex-direction: column;
        text-align: center;
      }
      .product-image-container img {
        width: 120px;
        height: 120px;
      }
    }
    .panel-title-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 16px;
    }
    .panel-title {
      font-size: 18px;
      color: #242949;
      margin-bottom: 16px;
    }
    .panel-subtitle {
      font-size: 14px;
      color: var(--text-muted);
      margin: 6px 0 16px;
    }
    .algorithm-recommendation-section {
      margin-bottom: 24px;
    }
    .algorithm-recommendation-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    .or-recommendation-section {
      margin-bottom: 20px;
    }
    .or-recommendation-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .algorithm-recommendation-value {
      background: var(--surface-muted);
      border-radius: 8px;
      padding: 16px 18px;
      border: 1px solid #dfe2ff;
      font-size: 14px;
      color: #2d3152;
      min-height: 24px;
    }
    .algorithm-recommendation-value .placeholder {
      color: var(--text-subtle);
      font-style: italic;
    }
    .algorithm-recommendation-value .recommendation-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 0;
    }
    .algorithm-recommendation-value .recommendation-item:not(:last-child) {
      border-bottom: 1px solid #e1e6ff;
      margin-bottom: 6px;
      padding-bottom: 8px;
    }
    .recommendation-formula {
      font-family: 'Courier New', monospace;
      font-size: 13px;
      line-height: 1.6;
    }
    .recommendation-formula .formula-main {
      margin-bottom: 8px;
      color: #2b2f53;
      font-size: 14px;
    }
    .recommendation-formula .formula-details {
      color: #494f78;
      font-size: 12px;
      margin-top: 8px;
    }
    .recommendation-formula .formula-details > div {
      margin-bottom: 4px;
    }
    .recommendation-formula .formula-result {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid #e1e6ff;
      color: #2b2f53;
      font-size: 13px;
    }
    .reasoning-section {
      margin-bottom: 24px;
    }
    .reasoning-text {
      background: #f4f6ff;
      border-radius: 8px;
      padding: 12px;
      line-height: 1.5;
      font-size: 14px;
      color: #2d3152;
      resize: vertical;
      cursor: default;
    }
    .reasoning-text:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
    }
    .order-decision-section {
      margin-bottom: 20px;
    }
    .news-card {
      width: 100%;
      background: #fef2ff;
      border-radius: 12px;
      padding: 14px 16px;
      border: 1px solid rgba(118, 75, 162, 0.25);
      box-shadow: 0 3px 10px rgba(118, 75, 162, 0.1);
    }
    .news-card.today {
      background: #fff6eb;
      border-color: rgba(255, 170, 43, 0.45);
    }
    .news-day {
      font-size: 13px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.6px;
      color: #af58c8;
      margin-bottom: 6px;
    }
    .news-card.today .news-day {
      color: #d98200;
    }
    .news-text {
      font-size: 14px;
      color: #3b3052;
      line-height: 1.45;
    }
    .historical-charts-panel {
      padding: 24px 26px;
      display: flex;
      flex-direction: column;
      gap: 24px;
    }
    .historical-demand-section,
    .historical-inventory-section {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .historical-demand-container {
      display: grid;
      grid-template-columns: 1fr 280px;
      gap: 20px;
      align-items: start;
    }
    .historical-inventory-container {
      display: grid;
      grid-template-columns: 1fr 280px;
      gap: 20px;
      align-items: start;
    }
    .historical-demand-chart-wrapper,
    .historical-inventory-chart-wrapper {
      position: relative;
      width: 100%;
      height: 300px;
    }
    .historical-demand-chart-wrapper canvas,
    .historical-inventory-chart-wrapper canvas {
      width: 100% !important;
      max-width: 100%;
      height: 100% !important;
    }
    .historical-demand-statistics {
      background: var(--surface-muted);
      border-radius: 12px;
      padding: 16px 18px;
      border: 1px solid #dfe2ff;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.6);
    }
    .historical-demand-statistics h4 {
      margin: 0 0 12px 0;
      font-size: 16px;
      color: #2c3053;
      font-weight: 600;
    }
    .statistics-content {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .statistic-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 14px;
    }
    .statistic-label {
      color: var(--text-muted);
      font-weight: 500;
    }
    .statistic-value {
      color: #2c3053;
      font-weight: 600;
      font-family: 'Courier New', monospace;
    }
    .statistics-group {
      margin-bottom: 16px;
    }
    .statistics-group:last-child {
      margin-bottom: 0;
    }
    .statistics-group h4 {
      margin: 0 0 12px 0;
      font-size: 16px;
      color: #2c3053;
      font-weight: 600;
    }
    .decision-panel {
      padding: 16px 18px;
      margin-top: auto;
    }
    .decision-panel .panel-subtitle {
      margin-bottom: 12px;
    }
    .decision-panel .row {
      gap: 12px;
      margin-bottom: 8px;
    }
    .decision-panel button {
      margin-top: 4px;
    }
    .button-row {
      display: flex;
      align-items: center;
      gap: 16px;
      margin-top: 12px;
    }
    .loading-text {
      font-size: 13px;
      color: var(--primary);
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .loading-text::before {
      content: "⏳";
      font-size: 14px;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    .row {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
    }
    .row > div {
      flex: 1 1 180px;
    }
    .error {
      color: #e74c3c;
      font-size: 13px;
      min-height: 18px;
    }
    .success {
      color: #27ae60;
      font-size: 13px;
      min-height: 18px;
      font-weight: 600;
    }
    .placeholder {
      color: var(--text-subtle);
      font-style: italic;
      font-size: 14px;
    }
    .transcript-panel {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .timeline {
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-height: 320px;
      overflow-y: auto;
      padding-right: 6px;
    }
    .timeline-entry {
      display: flex;
      gap: 12px;
      border-left: 3px solid rgba(118, 75, 162, 0.2);
      padding-left: 12px;
    }
    .timeline-entry .badge {
      font-size: 12px;
      font-weight: 600;
      color: #ffffff;
      background: var(--accent);
      border-radius: 999px;
      padding: 4px 10px;
      align-self: flex-start;
    }
    .timeline-entry .content {
      font-size: 13px;
      color: #2f3458;
      background: rgba(247, 248, 255, 0.95);
      border-radius: 8px;
      padding: 10px 12px;
      border: 1px solid rgba(118, 75, 162, 0.18);
      white-space: pre-wrap;
    }
    .raw-transcript {
      background: #1e1e1e;
      color: #d6f7c4;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      padding: 16px;
      border-radius: 8px;
      max-height: 320px;
      overflow-y: auto;
      white-space: pre-wrap;
      display: none;
    }
    .raw-transcript.visible {
      display: block;
    }
    .hidden {
      display: none !important;
    }
    @media (max-width: 960px) {
      header h1 {
        font-size: 24px;
      }
      main {
        padding: 20px 16px 36px;
      }
      .game-layout {
        flex-direction: column;
      }
      .column {
        min-width: 100%;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>🎮 Mode B: OR+LLM → Human decisions</h1>
    <p>View OR recommendations and LLM analysis — you make the final decision.</p>
  </header>

  <main>
    <section id="setup-section" class="panel">
      <h2>Game Setup</h2>
      <button id="start-btn">Start Game</button>
      <div id="start-error" class="error"></div>
    </section>

    <section id="game-section" class="hidden">
      <div class="game-layout">
        <div class="column column-left">
          <section class="panel snapshot-panel" id="snapshot-panel">
            <div id="product-info" class="product-info" style="display: none;">
              <div class="product-image-container">
                <img id="product-image" src="" alt="Product image" style="display: none;" onerror="this.style.display='none';" onload="this.style.display='block'; document.getElementById('product-info').style.display='flex';">
              </div>
              <div class="product-text">
                <div id="product-description"></div>
              </div>
            </div>
            <h3 class="snapshot-title">Snapshot: <span id="snapshot-week">Period 1</span></h3>
            <div class="snapshot-grid">
              <div class="snapshot-box">
                <div class="snapshot-label">Last period's demand</div>
                <div class="snapshot-value" id="snapshot-last-demand">—</div>
              </div>
              <div class="snapshot-box">
                <div class="snapshot-label">Total Reward</div>
                <div class="snapshot-value" id="snapshot-total-reward">—</div>
              </div>
              <div class="snapshot-box">
                <div class="snapshot-label">On-hand inventory</div>
                <div class="snapshot-value" id="snapshot-on-hand">—</div>
                <div class="snapshot-subtext" id="snapshot-received"> </div>
              </div>
              <div class="snapshot-box">
                <div class="snapshot-label">In-transit Inventory</div>
                <div class="snapshot-value" id="snapshot-in-transit">—</div>
              </div>
            </div>
            <div class="snapshot-cost-info">
              <div>profit/unit: <span id="snapshot-profit">—</span></div>
              <div>holding cost/unit: <span id="snapshot-holding-cost">—</span></div>
              <div>Promised lead time: <span id="snapshot-lead-time">—</span> periods</div>
              <div id="instance-3-warning" class="instance-3-warning" style="display: none; margin-top: 8px; padding: 8px; background-color: #fff3cd; border-left: 3px solid #ffc107; border-radius: 4px; font-size: 13px; color: #856404;">
                ⚠️ Note: For Instance 3, ordered inventory may never arrive with some probability.
              </div>
            </div>
          </section>

        </div>

        <div class="column column-right">
          <section class="panel decision-panel">
            <h3 class="panel-title">Order Decision</h3>
            
            <div class="or-recommendation-section">
              <div class="or-recommendation-header">
                <label class="input-label">OR Algorithm Recommendation (baseline)</label>
              </div>
              <div id="or-recommendation-value" class="algorithm-recommendation-value">
                <span class="placeholder">Waiting for OR recommendation...</span>
              </div>
            </div>

            <div class="algorithm-recommendation-section">
              <div class="algorithm-recommendation-header">
                <label class="input-label">LLM Recommendation (considers OR)</label>
              </div>
              <div id="algorithm-recommendation-value" class="algorithm-recommendation-value">
                <span class="placeholder">Waiting for AI recommendation...</span>
              </div>
            </div>

            <div class="reasoning-section">
              <label class="input-label">LLM Reasoning:</label>
              <textarea id="reasoning-text" readonly class="reasoning-text" placeholder="AI reasoning summary will appear here..."></textarea>
            </div>

            <div class="order-decision-section">
              <label class="input-label">Order decision:</label>
              <input id="order-quantity" type="number" min="0" placeholder="0" />
            </div>

            <div class="button-row">
              <button id="submit-decision-btn">SUBMIT</button>
              <span id="decision-loading" class="loading-text hidden">Submitting decision...</span>
            </div>
            <div id="decision-error" class="error"></div>
          </section>
        </div>
      </div>

      <section id="historical-charts-panel" class="panel historical-charts-panel">
        <div class="historical-demand-section">
          <h3 class="panel-title">Historical Demand</h3>
          <p class="panel-subtitle">Note: first 5 periods use sample demand data for initialization.</p>
          <div class="historical-demand-container">
            <div class="historical-demand-chart-wrapper">
              <canvas id="historical-demand-chart"></canvas>
            </div>
            <div class="historical-demand-statistics">
              <div id="historical-statistics" class="statistics-group">
                <h4>Historical Demand Statistics</h4>
                <div class="statistics-content">
                  <div class="statistic-item">
                    <span class="statistic-label">Average:</span>
                    <span class="statistic-value" id="demand-average">—</span>
                  </div>
                  <div class="statistic-item">
                    <span class="statistic-label">Standard deviation:</span>
                    <span class="statistic-value" id="demand-stddev">—</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="historical-inventory-section">
          <h3 class="panel-title">Historical Inventory Status</h3>
          <div class="historical-inventory-container">
            <div class="historical-inventory-chart-wrapper">
              <canvas id="historical-inventory-chart"></canvas>
            </div>
          </div>
        </div>
      </section>

      <section class="panel transcript-panel hidden">
        <div class="panel-title-row">
          <h3 class="panel-title">📜 Detailed Transcript</h3>
          <button id="toggle-transcript-btn" class="ghost">View Raw Log</button>
        </div>
        <div id="timeline-list" class="timeline">
          <p class="placeholder">Timeline will appear once the game begins.</p>
        </div>
        <div id="raw-transcript" class="raw-transcript"></div>
      </section>
    </section>
  </main>

  <script>
    // Check if user is logged in
    const userId = localStorage.getItem('user_id');
    if (!userId) {
      window.location.href = '/';
    }

    let currentRunId = null;
    let pollTimer = null;
    let latestProposalAction = null;
    let llmEventSource = null;  // SSE connection for LLM streaming

    const setupSection = document.getElementById("setup-section");
    const gameSection = document.getElementById("game-section");



    const orRecommendationEl = document.getElementById("or-recommendation-value");
    const algorithmRecommendationEl = document.getElementById("algorithm-recommendation-value");
    const reasoningTextEl = document.getElementById("reasoning-text");

    const timelineListEl = document.getElementById("timeline-list");
    const rawTranscriptEl = document.getElementById("raw-transcript");
    const toggleTranscriptBtn = document.getElementById("toggle-transcript-btn");
    let showingRawTranscript = false;
    const historicalChartsPanel = document.getElementById("historical-charts-panel");
    const historicalDemandCanvas = document.getElementById("historical-demand-chart");
    const historicalInventoryCanvas = document.getElementById("historical-inventory-chart");
    const demandAverageEl = document.getElementById("demand-average");
    const demandStdDevEl = document.getElementById("demand-stddev");
    const historicalStatisticsEl = document.getElementById("historical-statistics");

    if (toggleTranscriptBtn) {
      toggleTranscriptBtn.addEventListener("click", () => {
        showingRawTranscript = !showingRawTranscript;
        toggleTranscriptBtn.textContent = showingRawTranscript ? "View Timeline" : "View Raw Log";
        if (timelineListEl) {
          timelineListEl.classList.toggle("hidden", showingRawTranscript);
        }
        if (rawTranscriptEl) {
          rawTranscriptEl.classList.toggle("visible", showingRawTranscript);
        }
      });
    }

    const startError = document.getElementById("start-error");
    const decisionError = document.getElementById("decision-error");

    const submitDecisionBtn = document.getElementById("submit-decision-btn");
    const decisionLoading = document.getElementById("decision-loading");
    const orderQuantityInput = document.getElementById("order-quantity");

    let historicalDemandChartInstance = null;
    let historicalInventoryChartInstance = null;
    let latestState = null;
    let isDecisionSubmitting = false;
    let lastDisplayedPeriod = 0;  // Track last displayed period to detect period changes

    // Get instance parameter from URL query string
    const urlParams = new URLSearchParams(window.location.search);
    const instanceParam = urlParams.get('instance');
    const instance = instanceParam !== null ? parseInt(instanceParam, 10) : 0; // Default to 0 if not provided

    // Load product image and description
    async function loadProductInfo() {
      try {
        const productInfoEl = document.getElementById('product-info');
        const descEl = document.getElementById('product-description');
        const imgEl = document.getElementById('product-image');
        
        // Load description
        const descResponse = await fetch(`/instances/${instance}/description`);
        if (descResponse.ok) {
          const descData = await descResponse.json();
          if (descEl) {
            let descHTML = "";
            if (descData.product) {
              descHTML += `<div class="product-name">${escapeHtml(descData.product)}</div>`;
            }
            if (descData.description) {
              descHTML += `<div class="product-description-text">${escapeHtml(descData.description)}</div>`;
            }
            descEl.innerHTML = descHTML || "";
            
            // Show product info if we have at least description
            if (descHTML && productInfoEl) {
              productInfoEl.style.display = "flex";
            }
          }
        }
        
        // Load image
        if (imgEl) {
          imgEl.onload = function() {
            this.style.display = "block";
            if (productInfoEl) {
              productInfoEl.style.display = "flex";
            }
          };
          imgEl.onerror = function() {
            this.style.display = "none";
          };
          imgEl.src = `/instances/${instance}/image?t=${Date.now()}`;
        }
      } catch (err) {
        console.error('Error loading product info:', err);
      }
    }

    // Load product info when page loads
    loadProductInfo();

    document.getElementById("start-btn").addEventListener("click", async () => {
      startError.textContent = "";

      try {
        const response = await apiRequest("/runs", {
          method: "POST",
          body: JSON.stringify({
            mode: "modeB",
            enable_or: true,
            instance: instance,
          }),
        });
        currentRunId = response.run_id;
        setupSection.classList.add("hidden");
        gameSection.classList.remove("hidden");
        updateUI(response);
        startPolling();
      } catch (err) {
        startError.textContent = err.message || "Failed to start game";
      }
    });

    submitDecisionBtn.addEventListener("click", async () => {
      if (isDecisionSubmitting) return;
      decisionError.textContent = "";
      const orderQuantity = orderQuantityInput.value.trim();

      if (orderQuantity === "") {
        decisionError.textContent = "Please enter order quantity";
        return;
      }

      const qty = parseInt(orderQuantity, 10);

      if (!Number.isInteger(qty) || qty < 0) {
        decisionError.textContent = "Please enter a valid whole number (0 or greater)";
        return;
      }

      // Get item_id from latest proposal action
      let itemId = null;
      if (latestProposalAction && typeof latestProposalAction === 'object') {
        const itemIds = Object.keys(latestProposalAction);
        if (itemIds.length > 0) {
          itemId = itemIds[0];
        }
      }
      
      if (!itemId) {
        decisionError.textContent = "Cannot determine item ID. Please refresh the page.";
        return;
      }

      const actionJson = JSON.stringify({
        action: {
          [itemId]: qty
        }
      });

      isDecisionSubmitting = true;
      updateDecisionControls();

      try {
        const response = await apiRequest(`/runs/${currentRunId}/final-action`, {
          method: "POST",
          body: JSON.stringify({ action_json: actionJson }),
        });
        orderQuantityInput.value = "";
        
        // Check if game is completed
        if (response && response.completed) {
          const reward = response.final_reward || 0;
          decisionError.textContent = "";
          decisionError.className = "success";
          decisionError.textContent = `Game completed! Final reward: ${formatCurrency(reward)}`;
          if (pollTimer) {
            clearInterval(pollTimer);
            pollTimer = null;
          }
          stopLLMStreaming();
        } else {
          decisionError.textContent = "";
          decisionError.className = "error";
        }
        
        updateUI(response);
        startPolling();
      } catch (err) {
        // Check if error response contains completion info
        try {
          const errorText = err.message || "";
          // Try to parse error as JSON in case backend returns completion info in error
          const errorJson = JSON.parse(errorText);
          if (errorJson.completed) {
            const reward = errorJson.final_reward || 0;
            decisionError.className = "success";
            decisionError.textContent = `Game completed! Final reward: ${formatCurrency(reward)}`;
            if (pollTimer) {
              clearInterval(pollTimer);
              pollTimer = null;
            }
            // Still try to update UI if we have state
            if (errorJson.current_day !== undefined) {
              updateUI(errorJson);
            }
            return;
          }
        } catch (parseErr) {
          // Not JSON, treat as regular error
        }
        decisionError.className = "error";
        decisionError.textContent = err.message || "Failed to submit decision";
      } finally {
        isDecisionSubmitting = false;
        updateDecisionControls();
      }
    });

    function updateUI(state) {
      if (!state) return;
      latestState = state;
      renderSnapshot(state);
      renderORRecommendation(state.or_recommendation);
      renderOrderDecision(state.transcript || [], state.or_recommendation, state.streaming_text || "");
      renderTranscript(state.transcript || []);
      renderHistoricalCharts(state.daily_logs || [], state.current_day || 1, state.initial_samples || {}, state.initial_sample_dates || [], state.period_dates || {});

      const completed = !!state.completed;
      if (completed) {
        if (pollTimer) {
          clearInterval(pollTimer);
          pollTimer = null;
        }
        stopLLMStreaming();
        // Show completion message with reward
        const reward = state.final_reward || 0;
        if (decisionError) {
          decisionError.className = "success";
          decisionError.textContent = `Game completed! Final reward: ${formatCurrency(reward)}`;
        }
      }
      updateDecisionControls();
      requestAnimationFrame(syncColumnHeights);
    }


    function renderSnapshot(state) {
      const snapshotWeekEl = document.getElementById("snapshot-week");
      const snapshotLastDemandEl = document.getElementById("snapshot-last-demand");
      const snapshotTotalRewardEl = document.getElementById("snapshot-total-reward");
      const snapshotOnHandEl = document.getElementById("snapshot-on-hand");
      const snapshotInTransitEl = document.getElementById("snapshot-in-transit");
      const snapshotReceivedEl = document.getElementById("snapshot-received");
      const snapshotProfitEl = document.getElementById("snapshot-profit");
      const snapshotHoldingCostEl = document.getElementById("snapshot-holding-cost");
      const snapshotLeadTimeEl = document.getElementById("snapshot-lead-time");

      if (!snapshotWeekEl) return;

      const currentWeek = state.current_day || 1;
      const currentDate = state.current_period_date || state.period_dates?.[currentWeek] || null;
      const totalPeriods = state.total_periods || Object.keys(state.period_dates || {}).length || 0;
      
      // Build snapshot title: Period X (date) | Total: Y periods
      let snapshotText = `Period ${formatNumber(currentWeek)}`;
      if (currentDate && !currentDate.startsWith("Period_")) {
        snapshotText += ` (${currentDate})`;
      }
      if (totalPeriods > 0) {
        snapshotText += ` | Total: ${formatNumber(totalPeriods)} periods`;
      }
      snapshotWeekEl.textContent = snapshotText;

      // Last period's demand (previous period's requests)
      const dailyLogs = state.daily_logs || [];
      const lastWeekLog = dailyLogs.find(log => log.day === currentWeek - 1);
      let lastDemand = 0;
      if (lastWeekLog && lastWeekLog.requests) {
        lastDemand = Object.values(lastWeekLog.requests).reduce((sum, val) => sum + Number(val || 0), 0);
      }
      if (snapshotLastDemandEl) {
        snapshotLastDemandEl.textContent = formatNumber(lastDemand);
      }

      // Total Reward
      const reward = state.status_cards?.reward?.to_date || 0;
      if (snapshotTotalRewardEl) {
        snapshotTotalRewardEl.textContent = formatCurrency(reward);
      }

      // Inventory (single item now)
      const inventory = Array.isArray(state.status_cards?.inventory) ? state.status_cards.inventory : [];
      let item = inventory[0] || {};
      
      // Fallback: if inventory is empty or on_hand is missing (undefined), try to get from daily logs
      // Priority: current week's starting_inventory > previous week's ending_inventory
      // Note: 0 is a valid value, so we only use fallback if on_hand is undefined
      if ((!inventory.length || item.on_hand === undefined) && dailyLogs.length > 0) {
        // First try: current week's starting_inventory
        const currentWeekLog = dailyLogs.find(log => log.day === currentWeek);
        if (currentWeekLog && currentWeekLog.starting_inventory) {
          const itemIds = Object.keys(currentWeekLog.starting_inventory);
          if (itemIds.length > 0) {
            const firstItemId = itemIds[0];
            item = {
              ...item,
              on_hand: Number(currentWeekLog.starting_inventory[firstItemId] || 0),
            };
          }
        } else {
          // Second try: previous week's ending_inventory
          const previousWeekLog = dailyLogs.find(log => log.day === currentWeek - 1);
          if (previousWeekLog && previousWeekLog.ending_inventory) {
            const itemIds = Object.keys(previousWeekLog.ending_inventory);
            if (itemIds.length > 0) {
              const firstItemId = itemIds[0];
              item = {
                ...item,
                on_hand: Number(previousWeekLog.ending_inventory[firstItemId] || 0),
              };
            }
          }
        }
      }
      
      if (snapshotOnHandEl) {
        const onHandValue = item.on_hand !== undefined ? Number(item.on_hand) : 0;
        snapshotOnHandEl.textContent = formatNumber(onHandValue);
      }
      if (snapshotInTransitEl) {
        const inTransitValue = item.in_transit !== undefined ? Number(item.in_transit) : 0;
        snapshotInTransitEl.textContent = formatNumber(inTransitValue);
      }

      // Received this period (arrivals for current day)
      // Look for arrivals in the current period's daily log
      const currentWeekLog = dailyLogs.find(log => log.day === currentWeek);
      let receivedText = "";
      if (currentWeekLog && currentWeekLog.arrivals && typeof currentWeekLog.arrivals === "object") {
        const arrivals = currentWeekLog.arrivals;
        // Collect all arrivals from all items (supporting single item now, but extensible)
        const allReceivedItems = [];
        for (const itemId in arrivals) {
          if (arrivals.hasOwnProperty(itemId)) {
            const itemArrivals = arrivals[itemId];
            if (Array.isArray(itemArrivals) && itemArrivals.length > 0) {
              itemArrivals.forEach(entry => {
                const qty = Number(entry.quantity || entry[0] || 0);
                const orderWeek = Number(entry.order_day || entry[1] || 0);
                if (qty > 0 && orderWeek > 0) {
                  allReceivedItems.push(`${formatNumber(qty)} from period ${formatNumber(orderWeek)}`);
                }
              });
            }
          }
        }
        if (allReceivedItems.length > 0) {
          receivedText = `received this period: ${allReceivedItems.join(", ")}`;
        }
      }
      if (snapshotReceivedEl) {
        snapshotReceivedEl.textContent = receivedText;
      }

      // Cost info
      if (snapshotProfitEl) {
        snapshotProfitEl.textContent = formatCurrency(item.profit || 0);
      }
      if (snapshotHoldingCostEl) {
        snapshotHoldingCostEl.textContent = formatCurrency(item.holding_cost || 0);
      }

      // Promised lead time (periods)
      if (snapshotLeadTimeEl) {
        const promised = Number(state.promised_lead_time);
        snapshotLeadTimeEl.textContent = Number.isFinite(promised) ? formatNumber(promised) : "--";
      }

      // Show/hide instance 3 warning
      const instance3WarningEl = document.getElementById("instance-3-warning");
      if (instance3WarningEl) {
        instance3WarningEl.style.display = (instance === 3) ? "block" : "none";
      }
    }



    function syncColumnHeights() {
      const leftCol = document.querySelector(".column-left");
      const rightCol = document.querySelector(".column-right");
      if (!leftCol || !rightCol) return;

      // Let right column define overall height
      const layoutHeight = rightCol.getBoundingClientRect().height;
      leftCol.style.height = `${layoutHeight}px`;
    }

    window.addEventListener("resize", () => {
      requestAnimationFrame(syncColumnHeights);
    });

    function renderORRecommendation(orRecommendation) {
      if (!orRecommendationEl) return;
      
      if (!orRecommendation || typeof orRecommendation !== 'object') {
        orRecommendationEl.innerHTML = '<span class="placeholder">Waiting for OR recommendation...</span>';
        return;
      }

      const recommendations = orRecommendation.recommendations || {};
      const statistics = orRecommendation.statistics || {};
      const actionEntries = Object.entries(recommendations);

      if (actionEntries.length > 0) {
        const qty = actionEntries[0][1];
        
        // Display only the recommendation quantity
        orRecommendationEl.innerHTML = `
          <div class="recommendation-item">
            <strong>${formatNumber(qty)}</strong>
          </div>
        `;
      } else {
        orRecommendationEl.innerHTML = '<span class="placeholder">No OR recommendation yet.</span>';
      }
    }

    function renderOrderDecision(transcript, orRecommendation, streamingText) {
      // Get current period from latestState
      const currentPeriod = latestState ? (latestState.current_day || 1) : 1;
      
      // If period changed, clear old proposal display
      if (currentPeriod !== lastDisplayedPeriod) {
        lastDisplayedPeriod = currentPeriod;
        // Clear previous period's proposal display
        if (algorithmRecommendationEl) {
          algorithmRecommendationEl.innerHTML = '<span class="placeholder">Waiting for AI recommendation...</span>';
        }
        if (reasoningTextEl) {
          reasoningTextEl.value = "";
        }
        latestProposalAction = null;
        orderQuantityInput.value = "";
        window.lastReasoningLength = 0;
      }
      
      const proposal = findLatestProposalForPeriod(transcript, currentPeriod);
      
      // Render Algorithm recommendation
      if (!algorithmRecommendationEl) return;
      
      // Check if OR recommendation exists
      const hasORRecommendation = orRecommendation && 
                                  orRecommendation.recommendations && 
                                  Object.keys(orRecommendation.recommendations).length > 0;
      
      if (!proposal) {
        // If OR recommendation exists but LLM proposal doesn't, show "thinking"
        if (hasORRecommendation) {
          algorithmRecommendationEl.innerHTML = '<span class="placeholder">thinking</span>';

          // Show streaming text in reasoning area if available
          if (reasoningTextEl) {
            if (streamingText && streamingText.trim()) {
              // Skip JSON parsing for placeholder text like "Thinking..."
              let displayText = streamingText;
              if (!streamingText.startsWith("Thinking") && streamingText.trim().length > 10) {
                // Try to parse streaming JSON and extract rationale field for readability
                try {
                  const parsed = JSON.parse(streamingText);
                  if (parsed && typeof parsed === "object" && parsed.rationale) {
                    displayText = String(parsed.rationale);
                  }
                } catch (e) {
                  // If parsing fails, fall back to raw streamingText
                  // This is normal during streaming as JSON may be incomplete
                }
              }

              // Update textarea value with human-readable rationale (or raw text)
              reasoningTextEl.value = displayText;
              // Scroll to bottom to show latest text
              reasoningTextEl.scrollTop = reasoningTextEl.scrollHeight;
              // Only log occasionally to avoid console spam
              if (
                !window.lastReasoningLength ||
                Math.abs(displayText.length - window.lastReasoningLength) >= 50
              ) {
                console.log(
                  `DEBUG: Updated reasoning with streaming text, length: ${displayText.length}, preview: ${displayText.substring(
                    0,
                    50
                  )}...`
                );
                window.lastReasoningLength = displayText.length;
              }
            } else {
              reasoningTextEl.value = "";
              window.lastReasoningLength = 0;
            }
          }
        } else {
          algorithmRecommendationEl.innerHTML =
            '<span class="placeholder">Waiting for AI recommendation...</span>';
          if (reasoningTextEl) reasoningTextEl.value = "";
        }
        latestProposalAction = null;
        orderQuantityInput.value = "";
        return;
      }

      const payload = coerceAgentPayload(proposal.content);
      const action = coerceActionObject(payload.action);
      // When proposal is available, only show short_rationale_for_human (ignore streaming text)
      const rationale = payload.short_rationale_for_human || payload.rationale || "";

      const actionEntries = Object.entries(action);
      latestProposalAction = actionEntries.length ? action : null;

      // Display algorithm recommendation (quantity only, hide product ID)
      if (actionEntries.length > 0) {
        const qty = actionEntries[0][1];

        algorithmRecommendationEl.innerHTML = `
          <div class="recommendation-item">
            <strong>${formatNumber(qty)}</strong>
          </div>
        `;
        
        // Automatically populate order quantity input with LLM recommendation (single item support)
        const value = Number.isFinite(Number(qty)) ? Number(qty) : "";
        orderQuantityInput.value = value;
      } else {
        algorithmRecommendationEl.innerHTML = '<span class="placeholder">No explicit order proposal yet.</span>';
        orderQuantityInput.value = "";
      }

      // Display reasoning (read-only) - only show short_rationale_for_human when proposal is complete
      // Ignore streaming text when proposal exists
      if (reasoningTextEl) {
        reasoningTextEl.value = rationale;
      }
    }

    function findLatestProposal(transcript) {
      if (!Array.isArray(transcript)) return null;
      for (let i = transcript.length - 1; i >= 0; i -= 1) {
        const event = transcript[i];
        if (event && event.kind === "agent_proposal" && event.payload) {
          return event.payload;
        }
      }
      return null;
    }

    function findLatestProposalForPeriod(transcript, period) {
      if (!Array.isArray(transcript)) return null;
      for (let i = transcript.length - 1; i >= 0; i -= 1) {
        const event = transcript[i];
        if (event && event.kind === "agent_proposal" && event.payload) {
          // Check if this proposal is for the current period
          const proposalDay = event.payload.day || event.payload.payload?.day;
          if (proposalDay === period) {
            return event.payload;
          }
        }
      }
      return null;
    }

    function renderTranscript(transcript) {
      if (!timelineListEl || !rawTranscriptEl) return;
      if (!Array.isArray(transcript) || !transcript.length) {
        timelineListEl.innerHTML = `<p class="placeholder">Timeline will appear once the game begins.</p>`;
        rawTranscriptEl.textContent = "Transcript will appear once the game begins.";
      } else {
        timelineListEl.innerHTML = transcript.map(createTimelineEntry).join("");
        const rawLines = transcript.map((evt) => {
          const label = String(evt.kind || evt.role || "event").toUpperCase();
          const payload = evt.payload ?? evt.message ?? evt.data ?? evt;
          return `[${label}]\n${JSON.stringify(payload, null, 2)}`;
        });
        rawTranscriptEl.textContent = rawLines.join("\n\n");
      }
      if (toggleTranscriptBtn) {
        toggleTranscriptBtn.textContent = showingRawTranscript ? "View Timeline" : "View Raw Log";
      }
      timelineListEl.classList.toggle("hidden", showingRawTranscript);
      rawTranscriptEl.classList.toggle("visible", showingRawTranscript);
    }

    function createTimelineEntry(event) {
      const kindLabel = escapeHtml(String(event.kind || event.role || "event").toUpperCase());
      const content = summarizeTimelineContent(event);
      return `
        <article class="timeline-entry">
          <span class="badge">${kindLabel}</span>
          <div class="content">${content}</div>
        </article>
      `;
    }

    function summarizeTimelineContent(event) {
      if (!event) return "";
      if (event.message) {
        return escapeHtml(tryExtractString(event.message)).replace(/\n/g, "<br>");
      }
      const payload = event.payload ?? event.data ?? event.details;
      if (typeof payload === "string") {
        return escapeHtml(payload).replace(/\n/g, "<br>");
      }
      if (payload && typeof payload === "object") {
        return escapeHtml(JSON.stringify(payload, null, 2)).replace(/\n/g, "<br>");
      }
      return escapeHtml(JSON.stringify(event, null, 2)).replace(/\n/g, "<br>");
    }

    function renderHistoricalCharts(dailyLogs, currentDay, initialSamples, initialSampleDates, periodDates) {
      if (!historicalChartsPanel || !historicalDemandCanvas || !historicalInventoryCanvas) return;
      
      // Extract initial samples data
      let sampleData = [];
      let sampleDates = [];
      let hasSamples = false;
      if (initialSamples && typeof initialSamples === 'object') {
        const itemIds = Object.keys(initialSamples);
        if (itemIds.length > 0) {
          const samples = initialSamples[itemIds[0]];
          if (Array.isArray(samples) && samples.length > 0) {
            sampleData = samples;
            hasSamples = true;
            // Use provided dates or fallback to sample numbers
            if (Array.isArray(initialSampleDates) && initialSampleDates.length === samples.length) {
              sampleDates = initialSampleDates;
            } else {
              sampleDates = samples.map((_, index) => `Sample ${index + 1}`);
            }
          }
        }
      }
      
      // Filter logs: only include weeks up to currentDay - 1
      const filteredLogs = Array.isArray(dailyLogs) ? dailyLogs.filter((log) => log.day < currentDay) : [];
      
      // If no samples and no logs, hide the panel
      if (!hasSamples && filteredLogs.length === 0) {
        if (historicalChartsPanel) historicalChartsPanel.style.display = "none";
        if (historicalDemandChartInstance) {
          historicalDemandChartInstance.destroy();
          historicalDemandChartInstance = null;
        }
        if (historicalInventoryChartInstance) {
          historicalInventoryChartInstance.destroy();
          historicalInventoryChartInstance = null;
        }
        return;
      }

      historicalChartsPanel.style.display = "block";

      // Ensure canvas dimensions
      ensureCanvasDimensions(historicalDemandCanvas);
      ensureCanvasDimensions(historicalInventoryCanvas);

      // Prepare sample labels and data
      const sampleLabels = sampleDates.length > 0 ? sampleDates : sampleData.map((_, index) => `Sample ${index + 1}`);
      const sampleDemandData = [...sampleData]; // Gray line for samples

      // Prepare period labels and data (biweekly periods) - use exact dates if available
      const weekLabels = filteredLogs.map((log) => {
        // First try log.date, then period_dates map, then fallback to Period X
        if (log.date && !log.date.startsWith("Period_")) {
          return log.date;
        }
        // Look up date from period_dates map
        if (periodDates && periodDates[log.day]) {
          return periodDates[log.day];
        }
        // Fallback to Period X
        return `Period ${formatNumber(log.day)}`;
      });
      const weekDemandData = filteredLogs.map((log) => {
        const requests = log.requests || {};
        return Object.values(requests).reduce((sum, value) => sum + Number(value || 0), 0);
      });
      const weekDemandFulfilledData = filteredLogs.map((log) => {
        const sales = log.sales || {};
        return Object.values(sales).reduce((sum, value) => sum + Number(value || 0), 0);
      });

      // Calculate historical demand statistics including train CSV data (initial samples) and simulation data
      const combinedHistoricalData = [...sampleDemandData, ...weekDemandData];
      let demandAverage = 0;
      let demandStdDev = 0;
      if (combinedHistoricalData.length > 0) {
        demandAverage = combinedHistoricalData.reduce((sum, val) => sum + val, 0) / combinedHistoricalData.length;
        const demandVariance = combinedHistoricalData.reduce((sum, val) => sum + Math.pow(val - demandAverage, 2), 0) / combinedHistoricalData.length;
        demandStdDev = Math.sqrt(demandVariance);
      }

      // Update historical demand statistics display (always show)
      if (demandAverageEl) {
        demandAverageEl.textContent = combinedHistoricalData.length > 0 ? formatNumber(demandAverage, 1) : "—";
      }
      if (demandStdDevEl) {
        demandStdDevEl.textContent = combinedHistoricalData.length > 0 ? formatNumber(demandStdDev, 1) : "—";
      }
      if (historicalStatisticsEl) {
        historicalStatisticsEl.classList.remove("hidden");
      }

      // Combine labels and data - use exact dates throughout for continuous line
      const combinedLabels = [...sampleLabels, ...weekLabels];
      // Create a single continuous demand line combining historical samples and future demand
      const combinedDemandLine = [...sampleDemandData, ...weekDemandData];
      // Week demand fulfilled: null for samples, has values for weeks
      const combinedDemandFulfilled = [...Array(sampleLabels.length).fill(null), ...weekDemandFulfilledData];

      // Render Historical Demand chart
      if (historicalDemandChartInstance) {
        historicalDemandChartInstance.data.labels = combinedLabels;
        historicalDemandChartInstance.data.datasets[0].data = combinedDemandLine;
        historicalDemandChartInstance.data.datasets[1].data = combinedDemandFulfilled;
        historicalDemandChartInstance.update();
        historicalDemandChartInstance.resize();
      } else if (window.Chart && historicalDemandCanvas.getContext) {
        historicalDemandChartInstance = new Chart(historicalDemandCanvas.getContext("2d"), {
          type: "bar",
          data: {
            labels: combinedLabels,
            datasets: [
              {
                type: "line",
                label: "demand",
                data: combinedDemandLine,
                borderColor: "#000000",
                backgroundColor: "transparent",
                borderWidth: 2,
                pointRadius: 4,
                pointBackgroundColor: "#000000",
                pointBorderColor: "#ffffff",
                pointBorderWidth: 1,
                tension: 0,
                order: 2,
                spanGaps: false,
              },
              {
                type: "bar",
                label: "demand fulfilled",
                data: combinedDemandFulfilled,
                backgroundColor: "rgba(102, 126, 234, 0.6)",
                borderColor: "rgba(102, 126, 234, 0.8)",
                borderWidth: 1,
                order: 1,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
              mode: "index",
              intersect: false,
            },
            scales: {
              y: {
                beginAtZero: true,
                title: {
                  display: true,
                  text: "Units",
                },
                ticks: {
                  callback: (value) => formatNumber(value),
                },
                grid: {
                  color: "rgba(102, 126, 234, 0.15)",
                },
              },
              x: {
                grid: {
                  color: "rgba(102, 126, 234, 0.08)",
                },
              },
            },
            plugins: {
              legend: {
                display: true,
                position: "bottom",
                labels: {
                  usePointStyle: true,
                  generateLabels: (chart) => {
                    const original = Chart.defaults.plugins.legend.labels.generateLabels(chart);
                    const labels = [];
                    // Chart.js orders 'original' by dataset.order property (ascending)
                    // datasets[0]: sample (line, order:3), datasets[1]: demand (line, order:2), datasets[2]: demand fulfilled (bar, order:1)
                    // So: original[0] = demand fulfilled (order:1), original[1] = demand (order:2), original[2] = sample (order:3)
                    // Display order: sample (gray line), demand (black line), demand fulfilled (bar)
                    if (original[2]) {
                      // Sample line chart (gray) - from original[2] - show first (left)
                      const sampleLabel = { ...original[2] };
                      sampleLabel.fillStyle = "transparent";
                      sampleLabel.strokeStyle = "#9e9e9e";
                      sampleLabel.lineWidth = 2;
                      sampleLabel.pointStyle = "line";
                      labels.push(sampleLabel);
                    }
                    if (original[1]) {
                      // Demand line chart (black) - from original[1] - show second
                      const lineLabel = { ...original[1] };
                      lineLabel.fillStyle = "transparent";
                      lineLabel.strokeStyle = "#000000";
                      lineLabel.lineWidth = 2;
                      lineLabel.pointStyle = "line";
                      labels.push(lineLabel);
                    }
                    if (original[0]) {
                      // Bar chart (demand fulfilled) - from original[0] - show third (right)
                      const barLabel = { ...original[0] };
                      barLabel.fillStyle = "rgba(102, 126, 234, 0.6)";
                      barLabel.strokeStyle = "rgba(102, 126, 234, 0.8)";
                      barLabel.lineWidth = 1;
                      barLabel.pointStyle = "rect";
                      labels.push(barLabel);
                    }
                    return labels;
                  },
                },
              },
              tooltip: {
                callbacks: {
                  label: (ctx) => {
                    const label = ctx.dataset.label || "";
                    const value = formatNumber(ctx.parsed.y);
                    return `${label}: ${value}`;
                  },
                },
              },
            },
          },
        });
      }

      // Prepare data for Historical Inventory Status chart (aligned with demand chart)
      const weekOnHandData = filteredLogs.map((log) => {
        const ending = log.ending_inventory || {};
        return Object.values(ending).reduce((sum, value) => sum + Number(value || 0), 0);
      });
      const weekOrderData = filteredLogs.map((log) => {
        const orders = log.orders || {};
        return Object.values(orders).reduce((sum, value) => sum + Number(value || 0), 0);
      });
      
      // Combine with sample placeholders (null for sample positions)
      const combinedOnHandData = [...Array(sampleLabels.length).fill(null), ...weekOnHandData];
      const combinedOrderData = [...Array(sampleLabels.length).fill(null), ...weekOrderData];

      // Build order status data for bar styling
      const orderStatusData = filteredLogs.map((log) => {
        const orderStatus = log.order_status || [];
        if (!orderStatus.length) {
          return { arrivalWeek: null };
        }
        let earliestArrivalDay = null;
        orderStatus.forEach((entry) => {
          const rawDay = entry.arrival_day ?? entry.arrival_week;
          const numericDay = Number(rawDay);
          if (Number.isFinite(numericDay)) {
            earliestArrivalDay = earliestArrivalDay === null
              ? numericDay
              : Math.min(earliestArrivalDay, numericDay);
          }
        });
        const arrivalWeek = earliestArrivalDay !== null ? Math.floor(earliestArrivalDay) : null;
        return { arrivalWeek };
      });

      const orderVisualStatus = orderStatusData.map((status) => {
        const arrivalWeek = Number.isFinite(status.arrivalWeek)
          ? Number(status.arrivalWeek)
          : null;
        const arrivedNow = arrivalWeek !== null && arrivalWeek < currentDay;
        const arrivingToday = arrivalWeek !== null && arrivalWeek === currentDay;
        return { arrived: arrivedNow, arrivalWeek, arrivingToday };
      });

      // Helper to map a period number to a human-readable date label (if available)
      function getDateForPeriod(period) {
        const numeric = Number(period);
        if (!Number.isFinite(numeric)) return null;

        // First try: find matching daily log with a concrete date
        const matchingLog = filteredLogs.find((log) => log.day === numeric);
        if (matchingLog && typeof matchingLog.date === "string" && !matchingLog.date.startsWith("Period_")) {
          return matchingLog.date;
        }

        // Second try: look up in periodDates map (if provided)
        if (periodDates && typeof periodDates === "object") {
          const fromMap = periodDates[numeric];
          if (typeof fromMap === "string" && fromMap) {
            return fromMap;
          }
        }

        // No exact date available
        return null;
      }
      
      // Combine order visual status with sample placeholders (null for sample positions)
      const combinedOrderVisualStatus = [
        ...Array(sampleLabels.length).fill({ arrived: false, arrivalWeek: null, arrivingToday: false }),
        ...orderVisualStatus
      ];

      // Render Historical Inventory Status chart
      // Store orderStatusData in chart instance for tooltip access
      if (historicalInventoryChartInstance) {
        historicalInventoryChartInstance.data.labels = combinedLabels;
        // Update line chart dataset (on-hand inventory)
        historicalInventoryChartInstance.data.datasets[0].data = combinedOnHandData;
        historicalInventoryChartInstance.data.datasets[0].borderColor = "#e74c3c";
        historicalInventoryChartInstance.data.datasets[0].pointBackgroundColor = "#e74c3c";
        // Update bar chart dataset (order)
        const barBackgrounds = combinedOrderVisualStatus.map((status) =>
          status.arrived ? "rgba(46, 204, 113, 0.6)" : "transparent"
        );
        const barBorders = combinedOrderVisualStatus.map(() => "rgba(46, 204, 113, 0.8)");
        historicalInventoryChartInstance.data.datasets[1].data = combinedOrderData;
        historicalInventoryChartInstance.data.datasets[1].backgroundColor = barBackgrounds;
        historicalInventoryChartInstance.data.datasets[1].borderColor = barBorders;
        historicalInventoryChartInstance.data.datasets[1].borderWidth = 2;
        // Store orderStatusData for tooltip access
        historicalInventoryChartInstance.orderStatusData = combinedOrderVisualStatus;
        historicalInventoryChartInstance.update();
        historicalInventoryChartInstance.resize();
      } else if (window.Chart && historicalInventoryCanvas.getContext) {
        historicalInventoryChartInstance = new Chart(historicalInventoryCanvas.getContext("2d"), {
          type: "bar",
          data: {
            labels: combinedLabels,
            datasets: [
              {
                type: "line",
                label: "on-hand inventory",
                data: combinedOnHandData,
                borderColor: "#e74c3c",
                backgroundColor: "transparent",
                borderWidth: 2,
                pointRadius: 4,
                pointBackgroundColor: "#e74c3c",
                pointBorderColor: "#ffffff",
                pointBorderWidth: 1,
                tension: 0,
                order: 1, // Show line chart on top (lower order number = higher z-index)
              },
              {
                type: "bar",
                label: "order",
                data: combinedOrderData,
                backgroundColor: combinedOrderVisualStatus.map((status) =>
                  status.arrived ? "rgba(46, 204, 113, 0.6)" : "transparent"
                ),
                borderColor: combinedOrderVisualStatus.map(() => "rgba(46, 204, 113, 0.8)"),
                borderWidth: 2,
                borderSkipped: false,
                order: 2, // Show bar chart below line (higher order number = lower z-index)
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
              mode: "index",
              intersect: false,
            },
            scales: {
              y: {
                beginAtZero: true,
                title: {
                  display: true,
                  text: "Units",
                },
                ticks: {
                  callback: (value) => formatNumber(value),
                },
                grid: {
                  color: "rgba(102, 126, 234, 0.15)",
                },
              },
              x: {
                grid: {
                  color: "rgba(102, 126, 234, 0.08)",
                },
              },
            },
            plugins: {
              legend: {
                display: true,
                position: "bottom",
                labels: {
                  usePointStyle: true,
                  generateLabels: (chart) => {
                    const original = Chart.defaults.plugins.legend.labels.generateLabels(chart);
                    const labels = [];
                    // First: on-hand inventory (line chart, red)
                    if (original[0]) {
                      const lineLabel = { ...original[0] };
                      lineLabel.fillStyle = "transparent";
                      lineLabel.strokeStyle = "#e74c3c";
                      lineLabel.lineWidth = 2;
                      lineLabel.pointStyle = "line";
                      labels.push(lineLabel);
                    }
                    // Second: order (received) - green filled
                    if (original[1]) {
                      const receivedLabel = { ...original[1] };
                      receivedLabel.fillStyle = "rgba(46, 204, 113, 0.6)";
                      receivedLabel.strokeStyle = "rgba(46, 204, 113, 0.8)";
                      receivedLabel.lineWidth = 2;
                      receivedLabel.pointStyle = "rect";
                      receivedLabel.text = "order (received)";
                      labels.push(receivedLabel);
                    }
                    // Third: order (in-transit) - green border, transparent fill
                    if (original[1]) {
                      const inTransitLabel = { ...original[1] };
                      inTransitLabel.fillStyle = "transparent";
                      inTransitLabel.strokeStyle = "rgba(46, 204, 113, 0.8)";
                      inTransitLabel.lineWidth = 2;
                      inTransitLabel.pointStyle = "rect";
                      inTransitLabel.text = "order (in-transit)";
                      inTransitLabel.datasetIndex = -1;
                      labels.push(inTransitLabel);
                    }
                    return labels;
                  },
                },
              },
              tooltip: {
                callbacks: {
                  label: (ctx) => {
                    const label = ctx.dataset.label || "";
                    const value = formatNumber(ctx.parsed.y);
                    if (ctx.datasetIndex === 1 && ctx.parsed.y > 0) {
                      const orderStatusData = ctx.chart.orderStatusData || [];
                      const status = orderStatusData[ctx.dataIndex];
                      if (status) {
                        if (status.arrived && status.arrivalWeek !== null) {
                          const dateLabel = getDateForPeriod(status.arrivalWeek);
                          if (dateLabel) {
                            return `${label}: ${value} (received ${dateLabel})`;
                          }
                          return `${label}: ${value} (received)`;
                        }
                      }
                      return `${label}: ${value} (in-transit)`;
                    }
                    return `${label}: ${value}`;
                  },
                },
              },
            },
          },
        });
        // Store orderStatusData for tooltip access
        historicalInventoryChartInstance.orderStatusData = combinedOrderVisualStatus;
      }
    }

    function buildLineChartOptions({ yLabel, tooltipLabel }) {
      return {
        responsive: true,
        maintainAspectRatio: false,
        interaction: {
          mode: "index",
          intersect: false,
        },
        scales: {
          y: {
            title: {
              display: !!yLabel,
              text: yLabel || "",
            },
            ticks: {
              callback: (value) => formatNumber(value),
            },
            grid: {
              color: "rgba(102, 126, 234, 0.15)",
            },
          },
          x: {
            grid: {
              color: "rgba(102, 126, 234, 0.08)",
            },
          },
        },
        plugins: {
          legend: {
            display: true,
            position: "bottom",
          },
          tooltip: {
            callbacks: {
              label: tooltipLabel,
            },
          },
        },
      };
    }

    function ensureCanvasDimensions(canvas) {
      if (!canvas) return;
      const desired = 300;
      const width = canvas.clientWidth || (canvas.parentElement ? canvas.parentElement.clientWidth : 480);
      canvas.height = desired;
      canvas.style.height = `${desired}px`;
      canvas.style.maxHeight = `${desired}px`;
      if (width > 0) {
        canvas.width = width;
        canvas.style.width = "100%";
      }
    }

    function startLLMStreaming() {
      // Close existing SSE connection if any
      stopLLMStreaming();
      
      if (!currentRunId) return;
      
      // Open SSE connection for LLM streaming
      // Note: EventSource doesn't support custom headers, so we pass user_id as query param
      const userId = localStorage.getItem('user_id') || "anonymous";
      llmEventSource = new EventSource(`/runs/${currentRunId}/llm-stream?user_id=${encodeURIComponent(userId)}`);
      
      llmEventSource.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          
          if (data.complete) {
            // LLM proposal is complete, close SSE and refresh state
            stopLLMStreaming();
            // Poll once to get final state with proposal
            pollOnce();
            return;
          }
          
          // Update streaming text in UI
          if (data.streaming_text !== undefined) {
            // Update reasoning textarea with streaming text
            const reasoningTextEl = document.getElementById("reasoning-text");
            if (reasoningTextEl) {
              let displayText = data.streaming_text;
              // Try to parse and extract rationale if it's JSON
              if (!displayText.startsWith("Thinking") && displayText.trim().length > 10) {
                try {
                  const parsed = JSON.parse(displayText);
                  if (parsed && typeof parsed === "object" && parsed.rationale) {
                    displayText = String(parsed.rationale);
                  }
                } catch (e) {
                  // Not JSON, use as-is
                }
              }
              reasoningTextEl.value = displayText;
              reasoningTextEl.scrollTop = reasoningTextEl.scrollHeight;
            }
          }
        } catch (err) {
          console.error("Error parsing SSE data:", err);
        }
      };
      
      llmEventSource.onerror = (error) => {
        console.error("SSE connection error:", error);
        stopLLMStreaming();
        // Fall back to polling
        startPolling();
      };
    }
    
    function stopLLMStreaming() {
      if (llmEventSource) {
        llmEventSource.close();
        llmEventSource = null;
      }
    }
    
    function startPolling() {
      if (pollTimer) clearInterval(pollTimer);
      const pollInterval = 2000; // Poll every 2 seconds for non-LLM updates
      
      const poll = async () => {
        try {
          const state = await apiRequest(`/runs/${currentRunId}`, { method: "GET" });
          updateUI(state);
          
          const currentPeriod = state.current_day || 1;
          const hasLLMProposal = state.transcript && state.transcript.some(
            evt => {
              if (evt.kind === "agent_proposal" && evt.payload) {
                const proposalDay = evt.payload.day || evt.payload.payload?.day;
                return proposalDay === currentPeriod;
              }
              return false;
            }
          );
          
          // Check if we should start SSE for LLM streaming
          const hasORRecommendation = state.or_recommendation && 
                                      state.or_recommendation.recommendations && 
                                      Object.keys(state.or_recommendation.recommendations).length > 0;
          const waitingForLLM = hasORRecommendation && !hasLLMProposal && !state.completed;
          
          // Start SSE if waiting for LLM and not already streaming
          if (waitingForLLM && !llmEventSource) {
            startLLMStreaming();
          }
          
          // Stop polling if:
          // 1. Game is completed, OR
          // 2. We're waiting for final action AND LLM proposal is available
          if (state.completed || (state.waiting_for_final_action && hasLLMProposal)) {
            clearInterval(pollTimer);
            pollTimer = null;
            stopLLMStreaming();
          }
        } catch (err) {
          console.error("Polling error:", err);
        }
      };
      
      // Start with immediate poll, then continue with interval
      poll();
      pollTimer = setInterval(poll, pollInterval);
    }
    
    async function pollOnce() {
      if (!currentRunId) return;
      try {
        const state = await apiRequest(`/runs/${currentRunId}`, { method: "GET" });
        updateUI(state);
      } catch (err) {
        console.error("Poll error:", err);
      }
    }

    async function apiRequest(path, options = {}) {
      const userId = localStorage.getItem('user_id');
      const response = await fetch(path, {
        headers: {
          "Content-Type": "application/json",
          "X-User-ID": userId || "anonymous",
        },
        ...options,
      });
      if (!response.ok) {
        const text = await response.text();
        throw new Error(text || response.statusText);
      }
      return response.json();
    }

    function updateDecisionControls() {
      const completed = latestState ? !!latestState.completed : false;
      const waiting = latestState ? !!latestState.waiting_for_final_action : false;
      const disableSubmit = completed || !waiting || isDecisionSubmitting;
      const disableInputs = completed || isDecisionSubmitting;
      if (submitDecisionBtn) submitDecisionBtn.disabled = disableSubmit;
      if (orderQuantityInput) orderQuantityInput.disabled = disableInputs;
      if (decisionLoading) decisionLoading.classList.toggle("hidden", !isDecisionSubmitting);
    }

    updateDecisionControls();

    function formatCurrency(value) {
      const num = Number(value);
      if (!Number.isFinite(num)) return "$0.00";
      return `$${num.toFixed(2)}`;
    }

    function formatUnitCurrency(value) {
      const num = Number(value);
      if (!Number.isFinite(num)) return "$0.00";
      return `$${num.toFixed(2)}`;
    }

    function formatNumber(value, decimals = 0) {
      const num = Number(value);
      if (!Number.isFinite(num)) return "—";
      return num.toLocaleString(undefined, {
        minimumFractionDigits: decimals,
        maximumFractionDigits: decimals,
      });
    }

    function escapeHtml(str) {
      return str
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function tryExtractString(value) {
      if (value == null) return "";
      if (typeof value === "string") return value;
      if (typeof value === "object") return JSON.stringify(value);
      return String(value);
    }

    function coerceAgentPayload(content) {
      if (content && typeof content === "object" && !Array.isArray(content)) {
        return content;
      }
      const stringContent = tryExtractString(content);
      const parsed = tryParseJson(stringContent);
      if (parsed && typeof parsed === "object" && !Array.isArray(parsed)) {
        return parsed;
      }
      return { rationale: stringContent };
    }

    function coerceActionObject(action) {
      if (action && typeof action === "object" && !Array.isArray(action)) {
        return action;
      }
      const actionStr = tryExtractString(action);
      const parsed = tryParseJson(actionStr);
      if (parsed && typeof parsed === "object" && !Array.isArray(parsed)) {
        return parsed;
      }
      return {};
    }

    function tryParseJson(raw) {
      if (typeof raw !== "string") return null;
      let text = raw.trim();
      if (!text) return null;

      if (text.startsWith("```")) {
        text = text.replace(/^```(?:json)?/i, "").replace(/```$/i, "").trim();
      }
      if (/^json\s*/i.test(text)) {
        text = text.replace(/^json\s*/i, "");
      }

      const firstBrace = text.indexOf("{");
      const firstBracket = text.indexOf("[");
      let start = firstBrace;
      if (start === -1 || (firstBracket !== -1 && firstBracket < start)) {
        start = firstBracket;
      }
      if (start > 0) {
        text = text.slice(start);
      }

      const lastBrace = text.lastIndexOf("}");
      const lastBracket = text.lastIndexOf("]");
      let end = Math.max(lastBrace, lastBracket);
      if (end >= 0 && end < text.length - 1) {
        text = text.slice(0, end + 1);
      }

      try {
        return JSON.parse(text);
      } catch (err) {
        return null;
      }
    }
  </script>
</body>
</html>
