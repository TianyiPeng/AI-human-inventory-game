<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Mode C - Periodic Guidance</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.6/dist/chart.umd.min.js"></script>
  <style>
    :root {
      --primary: #764ba2;
      --primary-dark: #6a3f8f;
      --accent: #4f46e5;
      --surface: #ffffff;
      --surface-muted: #f6f5ff;
      --border-radius: 12px;
      --shadow: 0 6px 16px rgba(82, 67, 170, 0.12);
      --text-muted: #6b6f85;
      --text-subtle: #9aa0c1;
      --success: #27ae60;
      --warning: #f39c12;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: 'Segoe UI', Arial, sans-serif;
      background: linear-gradient(135deg, #ebe7ff 0%, #fdf2ff 100%);
      color: #1d2142;
    }
    header {
      background: var(--primary);
      color: var(--surface);
      padding: 22px;
      text-align: center;
      box-shadow: 0 6px 16px rgba(118, 75, 162, 0.25);
    }
    header h1 { margin: 0; font-size: 28px; }
    header p { margin: 8px 0 0; font-size: 15px; opacity: 0.92; }
    main {
      max-width: 1280px;
      margin: 0 auto;
      padding: 28px 24px 48px;
      display: flex;
      flex-direction: column;
      gap: 24px;
    }
    .panel {
      background: var(--surface);
      border-radius: var(--border-radius);
      box-shadow: var(--shadow);
      padding: 24px 26px;
    }
    .panel h2,
    .panel h3 { margin: 0; }
    .panel:not(:last-child) { margin-bottom: 4px; }
    label { display: block; margin-bottom: 8px; font-weight: 600; }
    input,
    textarea,
    button {
      width: 100%;
      padding: 12px;
      border-radius: 8px;
      border: 1px solid #d9def5;
      font-size: 14px;
      font-family: inherit;
    }
    textarea { min-height: 140px; resize: vertical; }
    input:focus,
    textarea:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(118, 75, 162, 0.18);
    }
    button {
      background: var(--primary);
      color: var(--surface);
      border: none;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease, background 0.2s ease;
    }
    button:hover:not(:disabled) { background: var(--primary-dark); transform: translateY(-1px); }
    button:disabled { background: #d5c6f3; cursor: not-allowed; }
    button.ghost {
      width: auto;
      padding: 8px 18px;
      background: transparent;
      color: var(--primary);
      border: 1px solid var(--primary);
      border-radius: 999px;
      font-size: 13px;
    }
    button.ghost:disabled { color: #b7a7d7; border-color: #ddd4f3; }
    .game-layout {
      display: flex;
      flex-wrap: nowrap;
      gap: 28px;
      align-items: stretch;
    }
    .column {
      flex: 1 1 360px;
      display: flex;
      flex-direction: column;
      gap: 24px;
      min-width: 320px;
      min-height: 100%;
    }
    .column-left { display: flex; flex-direction: column; gap: 24px; }
    .column-right { display: flex; flex-direction: column; gap: 24px; }
    .news-section {
      background: #f0f3ff;
      border-radius: 12px;
      border: 1px solid #d8dcff;
      padding: 18px 20px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      min-height: 220px;
      max-height: 240px;
      overflow: hidden;
    }
    .news-header { display: flex; align-items: baseline; justify-content: space-between; gap: 12px; }
    .news-header h3 { margin: 0; font-size: 18px; color: #2f3562; }
    .news-header span { font-size: 13px; color: var(--text-subtle); }
    .news-columns { display: grid; gap: 16px; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); flex: 1 1 auto; align-content: start; overflow-y: auto; padding-right: 6px; }
    .news-column { display: flex; flex-direction: column; gap: 10px; }
    .news-column h4 { margin: 0; font-size: 14px; color: #494f78; text-transform: uppercase; letter-spacing: 0.4px; }
    .news-list { display: flex; flex-direction: column; gap: 12px; flex: 1 1 auto; }
    .news-card { background: #fef2ff; border-radius: 12px; padding: 14px 16px; border: 1px solid rgba(118, 75, 162, 0.25); box-shadow: 0 3px 10px rgba(118, 75, 162, 0.1); }
    .news-card.today { background: #fff6eb; border-color: rgba(255, 170, 43, 0.45); }
    .news-day { font-size: 13px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.6px; color: #af58c8; margin-bottom: 6px; }
    .news-card.today .news-day { color: #d98200; }
    .news-text { font-size: 14px; color: #3b3052; line-height: 1.45; }
    .guidance-history-panel {
      background: #f9f3ff;
      border: 1px solid #e5d9f3;
      border-radius: 12px;
      padding: 18px 20px;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.6);
      display: flex;
      flex-direction: column;
      gap: 12px;
      color: #2b2f53;
    }
    .guidance-history-panel h3 {
      color: #764ba2;
      margin: 0;
      font-size: 17px;
      font-weight: 600;
    }
    .guidance-history { display: flex; flex-direction: column; gap: 10px; max-height: 220px; overflow-y: auto; padding-right: 6px; }
    .guidance-entry {
      background: rgba(255, 255, 255, 0.75);
      border-radius: 10px;
      border: 1px solid rgba(118, 75, 162, 0.25);
      padding: 10px 12px;
    }
    .guidance-entry header { display: flex; justify-content: space-between; align-items: baseline; font-weight: 600; font-size: 13px; color: #ffffff; }
    .guidance-entry header span { font-size: 12px; color: #ffffff; font-weight: 500; }
    .guidance-entry p { margin: 6px 0 0; font-size: 13px; color: #2f3158; white-space: pre-wrap; }
    .history-panel {
      background: #f9f3ff;
      border-radius: 12px;
      border: 1px solid #e5d9f3;
      padding: 18px 20px;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.6);
      flex: 0 0 auto;
      display: flex;
      flex-direction: column;
      gap: 14px;
      color: #2b2f53;
    }
    .history-panel h3 {
      color: #764ba2;
      margin: 0;
      font-size: 17px;
      font-weight: 600;
    }
    .game-history-panel {
      padding: 24px 26px;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    .game-history-panel .panel-title {
      font-size: 20px;
      font-weight: 600;
      color: #242949;
      margin: 0 0 16px 0;
    }
    .history-list {
      flex: 0 0 auto;
      max-height: 500px;
      overflow-y: auto;
      padding-right: 8px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .history-entry { background: rgba(255, 255, 255, 0.75); border-radius: 10px; border: 1px solid rgba(118, 75, 162, 0.25); padding: 16px 18px; display: flex; flex-direction: column; gap: 10px; }
    .history-entry header { display: flex; justify-content: space-between; align-items: baseline; font-weight: 600; color: #ffffff; font-size: 16px; }
    .history-entry header span { font-size: 14px; color: #ffffff; font-weight: 500; }
    .history-body { background: #fff; border-radius: 8px; border: 1px dashed rgba(118, 75, 162, 0.25); padding: 16px 18px; font-family: 'Segoe UI', Arial, sans-serif; font-size: 16px; color: #2f3158; white-space: pre-wrap; line-height: 1.8; }
    .snapshot-panel {
      padding: 22px 24px;
      display: flex;
      flex-direction: column;
      gap: 18px;
    }
    .snapshot-title {
      font-size: 18px;
      font-weight: 600;
      color: #242949;
      margin: 0 0 12px 0;
    }
    .snapshot-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    .snapshot-box {
      background: var(--surface-muted);
      border-radius: 10px;
      padding: 16px 18px;
      border: 1px solid #dde1fb;
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-height: 70px;
    }
    .snapshot-label {
      font-size: 13px;
      color: var(--text-muted);
      font-weight: 500;
    }
    .snapshot-value {
      font-size: 20px;
      font-weight: 700;
      color: #191c3a;
    }
    .snapshot-subtext {
      font-size: 11px;
      color: #9aa0c1;
      font-style: italic;
      margin-top: 4px;
    }
    .snapshot-cost-info {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 13px;
      color: var(--text-muted);
      margin-top: 8px;
    }
    .snapshot-cost-info span {
      font-weight: 600;
      color: #31355a;
    }
    .summary-card { display: flex; flex-direction: column; gap: 12px; }
    .summary-body { background: #f6f5ff; border-radius: 10px; border: 1px solid #dde1fb; padding: 14px 16px; font-size: 14px; color: #32355a; line-height: 1.5; }
    .summary-body.placeholder { color: var(--text-subtle); font-style: italic; }
    .summary-actions { display: grid; gap: 8px; }
    .summary-action { background: #fff; border: 1px solid rgba(118, 75, 162, 0.25); border-radius: 8px; padding: 8px 12px; display: flex; justify-content: space-between; align-items: center; font-size: 13px; }
    .hidden-card { display: none !important; }
    .guidance-panel { background: #f9f3ff; border: 1px solid rgba(118, 75, 162, 0.2); display: flex; flex-direction: column; gap: 14px; }
    .guidance-status { font-weight: 600; font-size: 14px; color: var(--primary); }
    .guidance-status.waiting { color: var(--warning); }
    .guidance-status.completed { color: var(--success); }
    .guidance-panel .info-box { background: rgba(255, 248, 230, 0.9); border: 1px solid rgba(255, 199, 92, 0.45); padding: 12px 14px; border-radius: 8px; color: #8a5b00; font-size: 13px; }
    .guidance-panel.disabled textarea,
    .guidance-panel.disabled button { opacity: 0.6; pointer-events: none; }
    .transcript-panel { display: flex; flex-direction: column; gap: 16px; }
    .panel-title-row { display: flex; justify-content: space-between; align-items: center; gap: 12px; }
    .timeline { display: flex; flex-direction: column; gap: 12px; max-height: 320px; overflow-y: auto; padding-right: 6px; }
    .timeline-entry { display: flex; gap: 12px; border-left: 3px solid rgba(118, 75, 162, 0.35); padding-left: 12px; }
    .timeline-entry .badge { font-size: 12px; font-weight: 600; color: #fff; background: var(--accent); border-radius: 999px; padding: 4px 10px; align-self: flex-start; }
    .timeline-entry .content { font-size: 13px; color: #373c63; white-space: pre-wrap; background: #f8f8ff; border-radius: 8px; padding: 10px 12px; border: 1px solid rgba(118, 75, 162, 0.18); }
    .raw-transcript { background: #1e1e1e; color: #cde9c8; font-family: 'Courier New', monospace; font-size: 13px; padding: 16px; border-radius: 8px; max-height: 320px; overflow-y: auto; white-space: pre-wrap; display: none; }
    .raw-transcript.visible { display: block; }
    .historical-charts-panel {
      padding: 24px 26px;
      display: flex;
      flex-direction: column;
      gap: 24px;
    }
    .historical-demand-section,
    .historical-inventory-section {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .historical-demand-container {
      display: grid;
      grid-template-columns: 1fr 280px;
      gap: 20px;
      align-items: start;
    }
    .historical-inventory-container {
      display: grid;
      grid-template-columns: 1fr 280px;
      gap: 20px;
      align-items: start;
    }
    .historical-demand-chart-wrapper,
    .historical-inventory-chart-wrapper {
      position: relative;
      width: 100%;
      height: 300px;
    }
    .historical-demand-chart-wrapper canvas,
    .historical-inventory-chart-wrapper canvas {
      width: 100% !important;
      max-width: 100%;
      height: 100% !important;
    }
    .historical-demand-statistics {
      background: var(--surface-muted);
      border-radius: 12px;
      padding: 16px 18px;
      border: 1px solid #dfe2ff;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.6);
    }
    .historical-demand-statistics h4 {
      margin: 0 0 12px 0;
      font-size: 16px;
      color: #2c3053;
      font-weight: 600;
    }
    .statistics-content {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .statistic-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 14px;
    }
    .statistic-label {
      color: var(--text-muted);
      font-weight: 500;
    }
    .statistic-value {
      color: #2c3053;
      font-weight: 600;
      font-family: 'Courier New', monospace;
    }
    .statistics-group {
      margin-bottom: 16px;
    }
    .statistics-group:last-child {
      margin-bottom: 0;
    }
    .statistics-group h4 {
      margin: 0 0 12px 0;
      font-size: 16px;
      color: #2c3053;
      font-weight: 600;
    }
    .error { color: #e74c3c; font-size: 13px; }
    .product-info {
      background: linear-gradient(135deg, #f8f9ff 0%, #f1f3ff 100%);
      border-radius: 12px;
      padding: 24px;
      border: 1px solid #e1e6ff;
      display: flex;
      align-items: center;
      gap: 24px;
    }
    .product-image-container {
      flex-shrink: 0;
    }
    .product-image-container img {
      width: 150px;
      height: 150px;
      object-fit: contain;
      border-radius: 8px;
      background: #ffffff;
      padding: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      border: 1px solid #e1e6ff;
    }
    .product-text {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .product-name {
      font-size: 18px;
      font-weight: 700;
      color: #161937;
      margin: 0;
    }
    .product-description-text {
      font-size: 14px;
      color: #5f6275;
      line-height: 1.6;
      margin: 0;
    }
    @media (max-width: 768px) {
      .product-info {
        flex-direction: column;
        text-align: center;
      }
      .product-image-container img {
        width: 120px;
        height: 120px;
      }
    }
    .placeholder { color: var(--text-subtle); font-style: italic; font-size: 14px; }
    .guidance-history .placeholder,
    .history-panel .placeholder { color: var(--text-subtle); }
    .hidden { display: none !important; }
    @media (max-width: 1024px) {
      .game-layout { flex-direction: column; }
      .column { min-width: 100%; }
      .news-section { max-height: none; }
      .guidance-history { max-height: none; }
    }
  </style>
</head>
<body>
  <header>
    <h1>🤖 Mode C: OR+LLM → Human strategic guidance</h1>
    <p>AI handles daily actions - you provide strategic guidance at scheduled pauses.</p>
  </header>

  <main>
    <section id="setup-section" class="panel">
      <h2>Game Setup</h2>
      <p class="placeholder" style="margin-bottom: 16px;">The AI will pause every 4 periods to request your strategic guidance.</p>
      <button id="start-btn">Start Game</button>
      <div id="start-error" class="error"></div>
    </section>

    <section id="game-section" class="hidden">
      <div class="game-layout">
        <div class="column column-left">
          <section class="panel snapshot-panel" id="snapshot-panel">
            <div id="product-info" class="product-info" style="display: none;">
              <div class="product-image-container">
                <img id="product-image" src="" alt="Product image" style="display: none;" onerror="this.style.display='none';" onload="this.style.display='block'; document.getElementById('product-info').style.display='flex';">
              </div>
              <div class="product-text">
                <div id="product-description"></div>
              </div>
            </div>
            <h3 class="snapshot-title">Snapshot: <span id="snapshot-week">Period 1</span></h3>
            <div class="snapshot-grid">
              <div class="snapshot-box">
                <div class="snapshot-label">Last period's demand</div>
                <div class="snapshot-value" id="snapshot-last-demand">—</div>
              </div>
              <div class="snapshot-box">
                <div class="snapshot-label">Total Reward</div>
                <div class="snapshot-value" id="snapshot-total-reward">—</div>
              </div>
              <div class="snapshot-box">
                <div class="snapshot-label">On-hand inventory</div>
                <div class="snapshot-value" id="snapshot-on-hand">—</div>
                <div class="snapshot-subtext" id="snapshot-received"> </div>
              </div>
              <div class="snapshot-box">
                <div class="snapshot-label">In-transit Inventory</div>
                <div class="snapshot-value" id="snapshot-in-transit">—</div>
              </div>
            </div>
            <div class="snapshot-cost-info">
              <div>profit/unit: <span id="snapshot-profit">—</span></div>
              <div>holding cost/unit: <span id="snapshot-holding-cost">—</span></div>
              <div>Promised lead time: <span id="snapshot-lead-time">—</span> periods</div>
              <div id="instance-3-warning" class="instance-3-warning" style="display: none; margin-top: 8px; padding: 8px; background-color: #fff3cd; border-left: 3px solid #ffc107; border-radius: 4px; font-size: 13px; color: #856404;">
                ⚠️ Note: For Instance 3, ordered inventory may never arrive with some probability.
              </div>
            </div>
          </section>
        </div>

        <div class="column column-right">
          <section class="panel guidance-panel" id="guidance-panel">
            <div id="guidance-status" class="guidance-status">AI is running...</div>
            <div class="info-box hidden" id="guidance-info">
              The AI is waiting for your strategic guidance. Provide high-level direction for the next phase.
            </div>
            <label>Your Strategic Guidance (optional - can be left blank)
              <textarea id="guidance-text" placeholder="Example: 'Make relatively conservative decisions.' Or leave blank to let AI continue autonomously."></textarea>
            </label>
            <button id="submit-guidance-btn">Submit Guidance</button>
            <div id="guidance-error" class="error"></div>
          </section>

          <section class="panel guidance-history-panel">
            <h3>Guidance Log</h3>
            <div id="guidance-history" class="guidance-history">
              <p class="placeholder">No guidance submitted yet.</p>
            </div>
          </section>
        </div>
      </div>

      <section id="game-history-panel" class="panel game-history-panel">
        <h3 class="panel-title">Game History</h3>
        <div id="history-list" class="history-list">
          <p class="placeholder">Game history will appear once the simulation progresses.</p>
        </div>
      </section>

      <section id="historical-charts-panel" class="panel historical-charts-panel">
        <div class="historical-demand-section">
          <h3 class="panel-title">Historical Demand</h3>
          <p class="panel-subtitle">Note: first 5 periods use sample demand data for initialization.</p>
          <div class="historical-demand-container">
            <div class="historical-demand-chart-wrapper">
              <canvas id="historical-demand-chart"></canvas>
            </div>
            <div class="historical-demand-statistics">
              <div id="historical-statistics" class="statistics-group">
                <h4>Historical Demand Statistics</h4>
                <div class="statistics-content">
                  <div class="statistic-item">
                    <span class="statistic-label">Average:</span>
                    <span class="statistic-value" id="demand-average">—</span>
                  </div>
                  <div class="statistic-item">
                    <span class="statistic-label">Standard deviation:</span>
                    <span class="statistic-value" id="demand-stddev">—</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="historical-inventory-section">
          <h3 class="panel-title">Historical Inventory Status</h3>
          <div class="historical-inventory-container">
            <div class="historical-inventory-chart-wrapper">
              <canvas id="historical-inventory-chart"></canvas>
            </div>
          </div>
        </div>
      </section>

      <section class="panel transcript-panel hidden">
        <div class="panel-title-row">
          <h3 class="panel-title">Detailed Transcript</h3>
          <button id="toggle-transcript-btn" class="ghost">View Raw Log</button>
        </div>
        <div id="timeline-list" class="timeline">
          <p class="placeholder">Timeline will populate as the simulation runs.</p>
        </div>
        <div id="raw-transcript" class="raw-transcript"></div>
      </section>
    </section>
  </main>

  <script>
    // Check if user is logged in
    const userId = localStorage.getItem('user_id');
    if (!userId) {
      window.location.href = '/';
    }

    let currentRunId = null;
    let pollTimer = null;
    let llmEventSource = null;  // SSE connection for LLM streaming
    let historicalDemandChartInstance = null;
    let historicalInventoryChartInstance = null;
    let showingRawTranscript = false;
    let productName = null; // Store product name for use in Game History
    const setupSection = document.getElementById("setup-section");
    const gameSection = document.getElementById("game-section");

    const guidanceHistoryEl = document.getElementById("guidance-history");
    const historyListEl = document.getElementById("history-list");

    const guidancePanel = document.getElementById("guidance-panel");
    const guidanceStatus = document.getElementById("guidance-status");
    const guidanceInfo = document.getElementById("guidance-info");
    const guidanceText = document.getElementById("guidance-text");
    const guidanceError = document.getElementById("guidance-error");
    const submitGuidanceBtn = document.getElementById("submit-guidance-btn");

    const timelineListEl = document.getElementById("timeline-list");
    const rawTranscriptEl = document.getElementById("raw-transcript");
    const toggleTranscriptBtn = document.getElementById("toggle-transcript-btn");

    const historicalChartsPanel = document.getElementById("historical-charts-panel");
    const historicalDemandCanvas = document.getElementById("historical-demand-chart");
    const historicalInventoryCanvas = document.getElementById("historical-inventory-chart");
    const demandAverageEl = document.getElementById("demand-average");
    const demandStdDevEl = document.getElementById("demand-stddev");
    const historicalStatisticsEl = document.getElementById("historical-statistics");

    document.getElementById("start-btn").addEventListener("click", startSimulation);
    submitGuidanceBtn.addEventListener("click", submitGuidance);
    toggleTranscriptBtn.addEventListener("click", () => {
      showingRawTranscript = !showingRawTranscript;
      toggleTranscriptBtn.textContent = showingRawTranscript ? "View Timeline" : "View Raw Log";
      if (timelineListEl) {
        timelineListEl.classList.toggle("hidden", showingRawTranscript);
      }
      if (rawTranscriptEl) {
        rawTranscriptEl.classList.toggle("visible", showingRawTranscript);
      }
    });

    async function startSimulation() {
      const startError = document.getElementById("start-error");
      startError.textContent = "";
      
      // Fixed guidance frequency: 4 periods
      const guidanceFrequency = 4;

      // Get instance parameter from URL query string
      const urlParams = new URLSearchParams(window.location.search);
      const instanceParam = urlParams.get('instance');
      const instance = instanceParam !== null ? parseInt(instanceParam, 10) : 0; // Default to 0 if not provided

      // Load product image and description
      async function loadProductInfo() {
        try {
          const productInfoEl = document.getElementById('product-info');
          const descEl = document.getElementById('product-description');
          const imgEl = document.getElementById('product-image');
          
          // Load description
          const descResponse = await fetch(`/instances/${instance}/description`);
          if (descResponse.ok) {
            const descData = await descResponse.json();
            // Store product name for use in Game History
            if (descData.product) {
              productName = descData.product;
            }
            if (descEl) {
              let descHTML = "";
              if (descData.product) {
                descHTML += `<div class="product-name">${escapeHtml(descData.product)}</div>`;
              }
              if (descData.description) {
                descHTML += `<div class="product-description-text">${escapeHtml(descData.description)}</div>`;
              }
              descEl.innerHTML = descHTML || "";
              
              // Show product info if we have at least description
              if (descHTML && productInfoEl) {
                productInfoEl.style.display = "flex";
              }
            }
          }
          
          // Load image
          if (imgEl) {
            imgEl.onload = function() {
              this.style.display = "block";
              if (productInfoEl) {
                productInfoEl.style.display = "flex";
              }
            };
            imgEl.onerror = function() {
              this.style.display = "none";
            };
            imgEl.src = `/instances/${instance}/image?t=${Date.now()}`;
          }
        } catch (err) {
          console.error('Error loading product info:', err);
        }
      }

      // Load product info when page loads
      loadProductInfo();

      try {
        const response = await apiRequest("/runs", {
          method: "POST",
          body: JSON.stringify({
            mode: "modeC",
            guidance_frequency: guidanceFrequency,
            enable_or: true,
            instance: instance,
          }),
        });
        currentRunId = response.run_id;
        setupSection.classList.add("hidden");
        gameSection.classList.remove("hidden");
        updateUI(response);
        startPolling();
        // Start SSE immediately for Mode C to receive period completion notifications
        // (We don't use it for LLM streaming, only for period completion events)
        startLLMStreaming();
      } catch (err) {
        startError.textContent = err.message || "Failed to start game";
      }
    }

    async function submitGuidance() {
      guidanceError.textContent = "";
      // Allow empty/blank guidance - user can submit without text to let AI continue autonomously
      const guidance = guidanceText.value ?? "";

      try {
        const response = await apiRequest(`/runs/${currentRunId}/guidance`, {
          method: "POST",
          body: JSON.stringify({ message: guidance }),
        });
        guidanceText.value = "";
        updateUI(response);
        startPolling();  // Start polling to get updates
        // Ensure SSE is connected for period completion notifications
        if (!llmEventSource) {
          startLLMStreaming();
        }
      } catch (err) {
        guidanceError.textContent = err.message || "Failed to submit guidance";
      }
    }
    function startLLMStreaming() {
      // Close existing SSE connection if any
      stopLLMStreaming();
      
      if (!currentRunId) return;
      
      // Open SSE connection for period completion notifications (not LLM streaming)
      // Mode C uses SSE only to detect when periods complete, not for streaming LLM text
      const userId = localStorage.getItem('user_id') || "anonymous";
      llmEventSource = new EventSource(`/runs/${currentRunId}/llm-stream?user_id=${encodeURIComponent(userId)}`);
      
      llmEventSource.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          
          // Handle LLM proposal completion - LLM just finished, period will complete soon
          if (data.llm_complete) {
            console.log(`LLM proposal complete for period ${data.period || 'unknown'}`);
            // LLM finished, poll immediately and again after a short delay
            pollRun();
            setTimeout(() => pollRun(), 200);
          }
          
          // Handle period completion notification - period finished its LLM call and advanced
          if (data.period_complete !== undefined) {
            console.log(`Period ${data.period_complete} completed! Current period: ${data.current_period}`);
            // Immediately poll to get updated state with period information
            pollRun();
            // Poll again after a short delay to ensure we get the full updated state
            setTimeout(() => pollRun(), 300);
          }
          
          // Handle period change notification - period advanced after completion
          if (data.period_changed !== undefined) {
            const completedPeriod = data.completed_period || data.previous_period;
            console.log(`Period ${completedPeriod} finished! Period changed from ${data.previous_period} to ${data.period_changed}`);
            // Immediately poll to get updated state with period information
            pollRun();
            // Poll again after a short delay to ensure we get the full updated state
            setTimeout(() => pollRun(), 300);
          }
          
          // Handle game completion
          if (data.game_complete) {
            stopLLMStreaming();
            pollRun();
            return;
          }
          
          // Ignore streaming_text for Mode C - we don't want to show LLM streaming
          // (data.streaming_text is ignored)
        } catch (err) {
          console.error("Error parsing SSE data:", err);
        }
      };
      
      llmEventSource.onerror = (error) => {
        console.error("SSE connection error:", error);
        // Don't stop completely - try to reconnect
        stopLLMStreaming();
        // Ensure polling continues even if SSE fails
        if (isPollingActive && currentRunId) {
          // Poll immediately to get latest state
          pollRun();
        }
        // Reconnect after a short delay
        setTimeout(() => {
          if (currentRunId && isPollingActive) {
            console.log("Reconnecting SSE after error...");
            startLLMStreaming();
          }
        }, 1000);
      };
    }
    
    function stopLLMStreaming() {
      if (llmEventSource) {
        llmEventSource.close();
        llmEventSource = null;
      }
    }
    
    let pollErrorCount = 0;
    const MAX_POLL_ERRORS = 5;
    let isPollingActive = false;

    function startPolling() {
      stopPolling();
      isPollingActive = true;
      pollErrorCount = 0;
      // Poll more frequently for Mode C to catch period updates quickly
      // Start with immediate poll, then continue with interval
      pollRun();  // Immediate poll
      pollTimer = setInterval(() => {
        if (isPollingActive) {
          pollRun();
        }
      }, 500);  // Poll every 500ms
    }

    function stopPolling() {
      isPollingActive = false;
      if (pollTimer) {
        clearInterval(pollTimer);
        pollTimer = null;
      }
      stopLLMStreaming();
    }

    async function pollRun() {
      if (!currentRunId || !isPollingActive) return;
      
      let state = null;
      try {
        state = await apiRequest(`/runs/${currentRunId}`, { method: "GET" });
        // Reset error count on successful poll
        pollErrorCount = 0;
        updateUI(state);
        
        // For Mode C: Don't start SSE based on streaming_text (we don't want LLM streaming)
        // Instead, keep SSE open for period completion notifications only
        // SSE is started when Mode C begins (in startRun function)
        
        if (state.completed) {
          stopPolling();
          stopLLMStreaming();
        }
      } catch (err) {
        pollErrorCount++;
        console.error(`Polling error (${pollErrorCount}/${MAX_POLL_ERRORS}):`, err);
        
        // If we've had too many errors, try to restart polling
        if (pollErrorCount >= MAX_POLL_ERRORS) {
          console.warn("Too many polling errors, attempting to restart polling...");
          pollErrorCount = 0;
          // Restart polling after a delay (only if game not completed)
          setTimeout(() => {
            if (currentRunId && isPollingActive && (!state || !state.completed)) {
              console.log("Restarting polling after errors...");
              startPolling();
            }
          }, 2000);
        }
        
        // Even on error, continue polling (don't stop silently)
        // The interval will continue, but we'll retry
      }
    }

    let lastDisplayedPeriod = 0;
    
    function updateUI(state) {
      if (!state) return;

      const currentPeriod = state.current_day || 1;
      
      // Show period completion notification when period advances
      if (currentPeriod > lastDisplayedPeriod && lastDisplayedPeriod > 0) {
        console.log(`Period ${lastDisplayedPeriod} completed! Now on period ${currentPeriod}`);
        // You could add a visual notification here if desired
        // e.g., show a toast notification or highlight the period in the UI
      }
      lastDisplayedPeriod = currentPeriod;

      renderSnapshot(state);
      renderHistory(state.daily_logs || [], state.transcript || []);
      renderGuidanceHistory(state.guidance_history || []);
      renderGuidancePanel(state);
      renderTimeline(state.transcript || []);
      renderHistoricalCharts(state.daily_logs || [], state.current_day || 1, state.initial_samples || {}, state.initial_sample_dates || [], state.period_dates || {});

      const completed = !!state.completed;
      if (submitGuidanceBtn) {
        submitGuidanceBtn.disabled = !state.waiting_for_guidance || completed;
      }
      if (guidanceText) {
        guidanceText.disabled = !state.waiting_for_guidance || completed;
      }

      if (completed) {
        stopPolling();
      }
    }
    function renderSnapshot(state) {
      const snapshotWeekEl = document.getElementById("snapshot-week");
      const snapshotLastDemandEl = document.getElementById("snapshot-last-demand");
      const snapshotTotalRewardEl = document.getElementById("snapshot-total-reward");
      const snapshotOnHandEl = document.getElementById("snapshot-on-hand");
      const snapshotInTransitEl = document.getElementById("snapshot-in-transit");
      const snapshotReceivedEl = document.getElementById("snapshot-received");
      const snapshotProfitEl = document.getElementById("snapshot-profit");
      const snapshotHoldingCostEl = document.getElementById("snapshot-holding-cost");
      const snapshotLeadTimeEl = document.getElementById("snapshot-lead-time");
      const instance3WarningEl = document.getElementById("instance-3-warning");

      if (!snapshotWeekEl) return;

      // Show/hide instance 3 warning
      if (instance3WarningEl) {
        const urlParams = new URLSearchParams(window.location.search);
        const instanceParam = urlParams.get('instance');
        const currentInstance = instanceParam !== null ? parseInt(instanceParam, 10) : 0;
        instance3WarningEl.style.display = (currentInstance === 3) ? "block" : "none";
      }

      const currentWeek = state.current_day || 1;
      const currentDate = state.current_period_date || state.period_dates?.[currentWeek] || null;
      const totalPeriods = state.total_periods || Object.keys(state.period_dates || {}).length || 0;
      
      // Build snapshot title: Period X (date) | Total: Y periods
      let snapshotText = `Period ${formatNumber(currentWeek)}`;
      if (currentDate && !currentDate.startsWith("Period_")) {
        snapshotText += ` (${currentDate})`;
      }
      if (totalPeriods > 0) {
        snapshotText += ` | Total: ${formatNumber(totalPeriods)} periods`;
      }
      snapshotWeekEl.textContent = snapshotText;

      // Last period's demand (previous period's requests)
      const dailyLogs = state.daily_logs || [];
      const lastWeekLog = dailyLogs.find(log => log.day === currentWeek - 1);
      let lastDemand = 0;
      if (lastWeekLog && lastWeekLog.requests) {
        lastDemand = Object.values(lastWeekLog.requests).reduce((sum, val) => sum + Number(val || 0), 0);
      }
      if (snapshotLastDemandEl) {
        snapshotLastDemandEl.textContent = formatNumber(lastDemand);
      }

      // Total Reward
      const reward = state.status_cards?.reward?.to_date || 0;
      if (snapshotTotalRewardEl) {
        snapshotTotalRewardEl.textContent = formatCurrency(reward);
      }

      // Inventory (single item now)
      const inventory = Array.isArray(state.status_cards?.inventory) ? state.status_cards.inventory : [];
      let item = inventory[0] || {};
      
      // Fallback: if inventory is empty or on_hand is missing (undefined), try to get from daily logs
      // Priority: current week's starting_inventory > previous week's ending_inventory
      // Note: 0 is a valid value, so we only use fallback if on_hand is undefined
      if ((!inventory.length || item.on_hand === undefined) && dailyLogs.length > 0) {
        // First try: current week's starting_inventory
        const currentWeekLog = dailyLogs.find(log => log.day === currentWeek);
        if (currentWeekLog && currentWeekLog.starting_inventory) {
          const itemIds = Object.keys(currentWeekLog.starting_inventory);
          if (itemIds.length > 0) {
            const firstItemId = itemIds[0];
            item = {
              ...item,
              on_hand: Number(currentWeekLog.starting_inventory[firstItemId] || 0),
            };
          }
        } else {
          // Second try: previous week's ending_inventory
          const previousWeekLog = dailyLogs.find(log => log.day === currentWeek - 1);
          if (previousWeekLog && previousWeekLog.ending_inventory) {
            const itemIds = Object.keys(previousWeekLog.ending_inventory);
            if (itemIds.length > 0) {
              const firstItemId = itemIds[0];
              item = {
                ...item,
                on_hand: Number(previousWeekLog.ending_inventory[firstItemId] || 0),
              };
            }
          }
        }
      }
      
      if (snapshotOnHandEl) {
        const onHandValue = item.on_hand !== undefined ? Number(item.on_hand) : 0;
        snapshotOnHandEl.textContent = formatNumber(onHandValue);
      }
      if (snapshotInTransitEl) {
        const inTransitValue = item.in_transit !== undefined ? Number(item.in_transit) : 0;
        snapshotInTransitEl.textContent = formatNumber(inTransitValue);
      }

      // Received this period (arrivals for current day)
      // Look for arrivals in the current week's daily log
      const currentWeekLog = dailyLogs.find(log => log.day === currentWeek);
      let receivedText = "";
      if (currentWeekLog && currentWeekLog.arrivals && typeof currentWeekLog.arrivals === "object") {
        const arrivals = currentWeekLog.arrivals;
        // Collect all arrivals from all items (supporting single item now, but extensible)
        const allReceivedItems = [];
        for (const itemId in arrivals) {
          if (arrivals.hasOwnProperty(itemId)) {
            const itemArrivals = arrivals[itemId];
            if (Array.isArray(itemArrivals) && itemArrivals.length > 0) {
              itemArrivals.forEach(entry => {
                const qty = Number(entry.quantity || entry[0] || 0);
                const orderWeek = Number(entry.order_day || entry[1] || 0);
                if (qty > 0 && orderWeek > 0) {
                  allReceivedItems.push(`${formatNumber(qty)} from period ${formatNumber(orderWeek)}`);
                }
              });
            }
          }
        }
        if (allReceivedItems.length > 0) {
          receivedText = `received this period: ${allReceivedItems.join(", ")}`;
        }
      }
      if (snapshotReceivedEl) {
        snapshotReceivedEl.textContent = receivedText;
      }

      // Cost info
      if (snapshotProfitEl) {
        snapshotProfitEl.textContent = formatCurrency(item.profit || 0);
      }
      if (snapshotHoldingCostEl) {
        snapshotHoldingCostEl.textContent = formatCurrency(item.holding_cost || 0);
      }

      // Promised lead time (periods)
      if (snapshotLeadTimeEl) {
        const promised = Number(state.promised_lead_time);
        snapshotLeadTimeEl.textContent = Number.isFinite(promised) ? formatNumber(promised) : "--";
      }
    }


    function renderHistory(dailyLogs, transcript) {
      if (!historyListEl) return;
      if (!Array.isArray(dailyLogs) || dailyLogs.length === 0) {
        historyListEl.innerHTML = `<p class="placeholder">Game history will appear once the simulation progresses.</p>`;
        return;
      }
      const sorted = dailyLogs.slice().sort((a, b) => Number(a.day || 0) - Number(b.day || 0));
      historyListEl.innerHTML = sorted.map(log => createHistoryEntry(log, transcript)).join("");
    }

    function createHistoryEntry(log, transcript) {
      const day = formatNumber(log.day);
      const reward = formatCurrency(log.daily_reward);
      const lines = buildHistoryLines(log);
      
      // Extract LLM short rationale for this period from transcript
      const shortRationale = extractShortRationaleForPeriod(transcript, log.day);
      
      // Add short rationale after the summary if available
      if (shortRationale) {
        lines.push("");
        lines.push(`LLM Reasoning: ${shortRationale}`);
      }
      
      const body = escapeHtml(lines.join("\n")).replace(/\n/g, "<br>");
      return `
        <article class="history-entry">
          <header>
            <div>Period ${day}</div>
            <span>Reward ${reward}</span>
          </header>
          <div class="history-body">${body}</div>
        </article>
      `;
    }

    function buildHistoryLines(log) {
      const lines = [];
      const items = [];
      const seen = new Set();
      const appendFrom = (source) => {
        if (!source) return;
        Object.keys(source).forEach((itemId) => {
          if (!seen.has(itemId)) {
            seen.add(itemId);
            items.push(itemId);
          }
        });
      };
      appendFrom(log.orders);
      appendFrom(log.requests);
      appendFrom(log.sales);
      appendFrom(log.starting_inventory);
      appendFrom(log.ending_inventory);

      items.sort((a, b) => a.localeCompare(b));

      items.forEach((itemId) => {
        const ordered = Number((log.orders || {})[itemId] ?? 0);
        const starting = Number((log.starting_inventory || {})[itemId] ?? 0);
        const demand = Number((log.requests || {})[itemId] ?? 0);
        const sold = Number((log.sales || {})[itemId] ?? 0);
        const ending = Number((log.ending_inventory || {})[itemId] ?? 0);
        const arrivalEntries = (log.arrivals && log.arrivals[itemId]) || [];
        let arrivalText = "0";
        if (Array.isArray(arrivalEntries) && arrivalEntries.length) {
          arrivalText = arrivalEntries
            .map((entry) => {
              const qty = formatNumber(entry.quantity ?? entry[0]);
              const day = formatNumber(entry.order_day ?? entry[1]);
              return `${qty} (from Period ${day})`;
            })
            .join(", ");
        }
        
        // Format: 3 lines for better readability
        // Use product name if available, otherwise fall back to itemId
        const displayName = productName || itemId;
        lines.push(`${displayName}:`);
        lines.push(`  Order & Arrival: ${formatNumber(ordered)} ordered, ${arrivalText} arrived`);
        lines.push(`  Demand & Sales: ${formatNumber(demand)} demand, ${formatNumber(sold)} sold`);
        lines.push(`  Inventory: ${formatNumber(starting)} starting → ${formatNumber(ending)} ending`);
      });

      return lines;
    }

    function extractShortRationaleForPeriod(transcript, period) {
      if (!Array.isArray(transcript)) return null;
      
      // Find the latest agent_proposal for this period
      for (let i = transcript.length - 1; i >= 0; i--) {
        const event = transcript[i];
        if (event && event.kind === "agent_proposal" && event.payload) {
          const payloadDay = event.payload.day;
          if (payloadDay === period) {
            const content = event.payload.content || {};
            // Prefer short_rationale_for_human, fallback to rationale
            return content.short_rationale_for_human || content.rationale || null;
          }
        }
      }
      return null;
    }

    function renderGuidanceHistory(history) {
      if (!guidanceHistoryEl) return;
      if (!Array.isArray(history) || history.length === 0) {
        guidanceHistoryEl.innerHTML = `<p class="placeholder">No guidance submitted yet.</p>`;
        return;
      }
      guidanceHistoryEl.innerHTML = history
        .map(({ day, message }, index) => {
          const safeMessage = escapeHtml(String(message ?? ""))
            .replace(/\n/g, "<br>");
          // If message is empty or only whitespace, show a friendly placeholder
          const displayMessage = (message && message.trim()) 
            ? safeMessage 
            : "<em style='color: #9aa0c1;'>(No specific guidance - AI continues autonomously)</em>";
          return `
            <div class="guidance-entry">
              <header>
                <span>Period ${formatNumber(day)} Guidance</span>
                <span>#${index + 1}</span>
              </header>
              <p>${displayMessage}</p>
            </div>
          `;
        })
        .join("");
    }

    function renderGuidancePanel(state) {
      if (!guidancePanel || !guidanceStatus || !guidanceInfo) return;
      guidancePanel.classList.toggle("disabled", !state.waiting_for_guidance || state.completed);
      guidanceStatus.classList.remove("waiting", "completed");
      if (state.completed) {
        guidanceStatus.textContent = "Simulation completed";
        guidanceStatus.classList.add("completed");
        guidanceInfo.classList.add("hidden");
        return;
      }
      if (state.waiting_for_guidance) {
        guidanceStatus.textContent = `Awaiting guidance for Period ${formatNumber(state.current_day)}`;
        guidanceStatus.classList.add("waiting");
        guidanceInfo.classList.remove("hidden");
      } else {
        guidanceStatus.textContent = "AI is running...";
        guidanceInfo.classList.add("hidden");
      }
    }
    function renderTimeline(transcript) {
      if (!timelineListEl || !rawTranscriptEl) return;
      if (!Array.isArray(transcript) || transcript.length === 0) {
        timelineListEl.innerHTML = `<p class="placeholder">Timeline will populate as the simulation runs.</p>`;
        renderRawTranscript([]);
      } else {
        timelineListEl.innerHTML = transcript.map(createTimelineEntry).join("");
        renderRawTranscript(transcript);
      }
      if (toggleTranscriptBtn) {
        toggleTranscriptBtn.textContent = showingRawTranscript ? "View Timeline" : "View Raw Log";
      }
      timelineListEl.classList.toggle("hidden", showingRawTranscript);
      rawTranscriptEl.classList.toggle("visible", showingRawTranscript);
    }

    function createTimelineEntry(event) {
      const kindLabel = escapeHtml(String(event.kind || event.role || "event").toUpperCase());
      const content = summarizeTimelineContent(event);
      return `
        <article class="timeline-entry">
          <span class="badge">${kindLabel}</span>
          <div class="content">${content}</div>
        </article>
      `;
    }

    function summarizeTimelineContent(event) {
      if (!event) return "";
      if (event.message) {
        return escapeHtml(tryExtractString(event.message)).replace(/\n/g, "<br>");
      }
      const payload = event.payload ?? event.data ?? event.details;
      if (typeof payload === "string") {
        return escapeHtml(payload).replace(/\n/g, "<br>");
      }
      if (payload && typeof payload === "object") {
        return escapeHtml(JSON.stringify(payload, null, 2)).replace(/\n/g, "<br>");
      }
      return escapeHtml(JSON.stringify(event, null, 2)).replace(/\n/g, "<br>");
    }

    function renderRawTranscript(transcript) {
      if (!rawTranscriptEl) return;
      if (!Array.isArray(transcript) || transcript.length === 0) {
        rawTranscriptEl.textContent = "Transcript will appear once the simulation begins.";
        return;
      }
      const text = transcript
        .map((evt) => {
          const label = String(evt.kind || evt.role || "event").toUpperCase();
          const payload = evt.payload ?? evt.message ?? evt.data ?? evt;
          return `[${label}]\n${JSON.stringify(payload, null, 2)}`;
        })
        .join("\n\n");
      rawTranscriptEl.textContent = text;
    }
    function renderHistoricalCharts(dailyLogs, currentDay, initialSamples, initialSampleDates, periodDates) {
      if (!historicalChartsPanel || !historicalDemandCanvas || !historicalInventoryCanvas) return;
      
      // Extract initial samples data
      let sampleData = [];
      let sampleDates = [];
      let hasSamples = false;
      if (initialSamples && typeof initialSamples === 'object') {
        const itemIds = Object.keys(initialSamples);
        if (itemIds.length > 0) {
          const samples = initialSamples[itemIds[0]];
          if (Array.isArray(samples) && samples.length > 0) {
            sampleData = samples;
            hasSamples = true;
            // Use provided dates or fallback to sample numbers
            if (Array.isArray(initialSampleDates) && initialSampleDates.length === samples.length) {
              sampleDates = initialSampleDates;
            } else {
              sampleDates = samples.map((_, index) => `Sample ${index + 1}`);
            }
          }
        }
      }
      
      // Filter logs: only include weeks up to currentDay - 1
      const filteredLogs = Array.isArray(dailyLogs) ? dailyLogs.filter((log) => log.day < currentDay) : [];
      
      // If no samples and no logs, hide the panel
      if (!hasSamples && filteredLogs.length === 0) {
        if (historicalChartsPanel) historicalChartsPanel.style.display = "none";
        if (historicalDemandChartInstance) {
          historicalDemandChartInstance.destroy();
          historicalDemandChartInstance = null;
        }
        if (historicalInventoryChartInstance) {
          historicalInventoryChartInstance.destroy();
          historicalInventoryChartInstance = null;
        }
        return;
      }

      historicalChartsPanel.style.display = "block";

      // Ensure canvas dimensions
      ensureCanvasDimensions(historicalDemandCanvas);
      ensureCanvasDimensions(historicalInventoryCanvas);

      // Prepare sample labels and data
      const sampleLabels = sampleDates.length > 0 ? sampleDates : sampleData.map((_, index) => `Sample ${index + 1}`);
      const sampleDemandData = [...sampleData];

      // Prepare week labels and data
      // Prepare period labels and data (biweekly periods) - use exact dates if available
      const weekLabels = filteredLogs.map((log) => {
        // First try log.date, then period_dates map, then fallback to Period X
        if (log.date && !log.date.startsWith("Period_")) {
          return log.date;
        }
        // Look up date from period_dates map
        if (periodDates && periodDates[log.day]) {
          return periodDates[log.day];
        }
        // Fallback to Period X
        return `Period ${formatNumber(log.day)}`;
      });
      const weekDemandData = filteredLogs.map((log) => {
        const requests = log.requests || {};
        return Object.values(requests).reduce((sum, value) => sum + Number(value || 0), 0);
      });
      const weekDemandFulfilledData = filteredLogs.map((log) => {
        const sales = log.sales || {};
        return Object.values(sales).reduce((sum, value) => sum + Number(value || 0), 0);
      });

      // Calculate historical demand statistics including train CSV data (initial samples) and simulation data
      const combinedHistoricalData = [...sampleDemandData, ...weekDemandData];
      let demandAverage = 0;
      let demandStdDev = 0;
      if (combinedHistoricalData.length > 0) {
        demandAverage = combinedHistoricalData.reduce((sum, val) => sum + val, 0) / combinedHistoricalData.length;
        const demandVariance = combinedHistoricalData.reduce((sum, val) => sum + Math.pow(val - demandAverage, 2), 0) / combinedHistoricalData.length;
        demandStdDev = Math.sqrt(demandVariance);
      }

      // Update historical demand statistics display (always show)
      if (demandAverageEl) {
        demandAverageEl.textContent = combinedHistoricalData.length > 0 ? formatNumber(demandAverage, 1) : "—";
      }
      if (demandStdDevEl) {
        demandStdDevEl.textContent = combinedHistoricalData.length > 0 ? formatNumber(demandStdDev, 1) : "—";
      }
      if (historicalStatisticsEl) {
        historicalStatisticsEl.classList.remove("hidden");
      }

      // Combine labels and data
      // Combine labels and data - use exact dates throughout for continuous line
      const combinedLabels = [...sampleLabels, ...weekLabels];
      // Create a single continuous demand line combining historical samples and future demand
      const combinedDemandLine = [...sampleDemandData, ...weekDemandData];
      const combinedDemandFulfilled = [...Array(sampleLabels.length).fill(null), ...weekDemandFulfilledData];

      // Render Historical Demand chart
      if (historicalDemandChartInstance) {
        historicalDemandChartInstance.data.labels = combinedLabels;
        historicalDemandChartInstance.data.datasets[0].data = combinedDemandLine;
        historicalDemandChartInstance.data.datasets[1].data = combinedDemandFulfilled;
        historicalDemandChartInstance.update();
        historicalDemandChartInstance.resize();
      } else if (window.Chart && historicalDemandCanvas.getContext) {
        historicalDemandChartInstance = new Chart(historicalDemandCanvas.getContext("2d"), {
          type: "bar",
          data: {
            labels: combinedLabels,
            datasets: [
              {
                type: "line",
                label: "demand",
                data: combinedDemandLine,
                borderColor: "#000000",
                backgroundColor: "transparent",
                borderWidth: 2,
                pointRadius: 4,
                pointBackgroundColor: "#000000",
                pointBorderColor: "#ffffff",
                pointBorderWidth: 1,
                tension: 0,
                order: 2,
                spanGaps: false,
              },
              {
                type: "bar",
                label: "demand fulfilled",
                data: combinedDemandFulfilled,
                backgroundColor: "rgba(102, 126, 234, 0.6)",
                borderColor: "rgba(102, 126, 234, 0.8)",
                borderWidth: 1,
                order: 1,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
              mode: "index",
              intersect: false,
            },
            scales: {
              y: {
                beginAtZero: true,
                title: {
                  display: true,
                  text: "Units",
                },
                ticks: {
                  callback: (value) => formatNumber(value),
                },
                grid: {
                  color: "rgba(102, 126, 234, 0.15)",
                },
              },
              x: {
                grid: {
                  color: "rgba(102, 126, 234, 0.08)",
                },
              },
            },
            plugins: {
              legend: {
                display: true,
                position: "bottom",
                labels: {
                  usePointStyle: true,
                  generateLabels: (chart) => {
                    const original = Chart.defaults.plugins.legend.labels.generateLabels(chart);
                    const labels = [];
                    // Chart.js orders 'original' by dataset.order property (ascending)
                    // datasets[0]: sample (line, order:3), datasets[1]: demand (line, order:2), datasets[2]: demand fulfilled (bar, order:1)
                    // So: original[0] = demand fulfilled (order:1), original[1] = demand (order:2), original[2] = sample (order:3)
                    // Display order: sample (gray line), demand (black line), demand fulfilled (bar)
                    if (original[2]) {
                      // Sample line chart (gray) - from original[2] - show first (left)
                      const sampleLabel = { ...original[2] };
                      sampleLabel.fillStyle = "transparent";
                      sampleLabel.strokeStyle = "#9e9e9e";
                      sampleLabel.lineWidth = 2;
                      sampleLabel.pointStyle = "line";
                      labels.push(sampleLabel);
                    }
                    if (original[1]) {
                      // Demand line chart (black) - from original[1] - show second
                      const lineLabel = { ...original[1] };
                      lineLabel.fillStyle = "transparent";
                      lineLabel.strokeStyle = "#000000";
                      lineLabel.lineWidth = 2;
                      lineLabel.pointStyle = "line";
                      labels.push(lineLabel);
                    }
                    if (original[0]) {
                      // Bar chart (demand fulfilled) - from original[0] - show third (right)
                      const barLabel = { ...original[0] };
                      barLabel.fillStyle = "rgba(102, 126, 234, 0.6)";
                      barLabel.strokeStyle = "rgba(102, 126, 234, 0.8)";
                      barLabel.lineWidth = 1;
                      barLabel.pointStyle = "rect";
                      labels.push(barLabel);
                    }
                    return labels;
                  },
                },
              },
              tooltip: {
                callbacks: {
                  label: (ctx) => {
                    const label = ctx.dataset.label || "";
                    const value = formatNumber(ctx.parsed.y);
                    return `${label}: ${value}`;
                  },
                },
              },
            },
          },
        });
      }

      // Prepare data for Historical Inventory Status chart (aligned with demand chart)
      const weekOnHandData = filteredLogs.map((log) => {
        const ending = log.ending_inventory || {};
        return Object.values(ending).reduce((sum, value) => sum + Number(value || 0), 0);
      });
      const weekOrderData = filteredLogs.map((log) => {
        const orders = log.orders || {};
        return Object.values(orders).reduce((sum, value) => sum + Number(value || 0), 0);
      });
      
      // Combine with sample placeholders (null for sample positions)
      const combinedOnHandData = [...Array(sampleLabels.length).fill(null), ...weekOnHandData];
      const combinedOrderData = [...Array(sampleLabels.length).fill(null), ...weekOrderData];

      // Build order status data for bar styling
      const orderStatusData = filteredLogs.map((log) => {
        const orderStatus = log.order_status || [];
        if (!orderStatus.length) {
          return { arrivalWeek: null };
        }
        let earliestArrivalDay = null;
        orderStatus.forEach((entry) => {
          const rawDay = entry.arrival_day ?? entry.arrival_week;
          const numericDay = Number(rawDay);
          if (Number.isFinite(numericDay)) {
            earliestArrivalDay = earliestArrivalDay === null
              ? numericDay
              : Math.min(earliestArrivalDay, numericDay);
          }
        });
        const arrivalWeek = earliestArrivalDay !== null ? Math.floor(earliestArrivalDay) : null;
        return { arrivalWeek };
      });

      const orderVisualStatus = orderStatusData.map((status) => {
        const arrivalWeek = Number.isFinite(status.arrivalWeek)
          ? Number(status.arrivalWeek)
          : null;
        const arrivedNow = arrivalWeek !== null && arrivalWeek < currentDay;
        const arrivingToday = arrivalWeek !== null && arrivalWeek === currentDay;
        return { arrived: arrivedNow, arrivalWeek, arrivingToday };
      });

      // Helper to map a period number to a human-readable date label (if available)
      function getDateForPeriod(period) {
        const numeric = Number(period);
        if (!Number.isFinite(numeric)) return null;

        // First try: find matching daily log with a concrete date
        const matchingLog = filteredLogs.find((log) => log.day === numeric);
        if (matchingLog && typeof matchingLog.date === "string" && !matchingLog.date.startsWith("Period_")) {
          return matchingLog.date;
        }

        // Second try: look up in periodDates map (if provided)
        if (periodDates && typeof periodDates === "object") {
          const fromMap = periodDates[numeric];
          if (typeof fromMap === "string" && fromMap) {
            return fromMap;
          }
        }

        // No exact date available
        return null;
      }
      
      // Combine order visual status with sample placeholders (null for sample positions)
      const combinedOrderVisualStatus = [
        ...Array(sampleLabels.length).fill({ arrived: false, arrivalWeek: null, arrivingToday: false }),
        ...orderVisualStatus
      ];

      // Render Historical Inventory Status chart
      // Store orderStatusData in chart instance for tooltip access
      if (historicalInventoryChartInstance) {
        historicalInventoryChartInstance.data.labels = combinedLabels;
        // Update line chart dataset (on-hand inventory)
        historicalInventoryChartInstance.data.datasets[0].data = combinedOnHandData;
        historicalInventoryChartInstance.data.datasets[0].borderColor = "#e74c3c";
        historicalInventoryChartInstance.data.datasets[0].pointBackgroundColor = "#e74c3c";
        // Update bar chart dataset (order)
        const barBackgrounds = combinedOrderVisualStatus.map((status) =>
          status.arrived ? "rgba(46, 204, 113, 0.6)" : "transparent"
        );
        const barBorders = combinedOrderVisualStatus.map(() => "rgba(46, 204, 113, 0.8)");
        historicalInventoryChartInstance.data.datasets[1].data = combinedOrderData;
        historicalInventoryChartInstance.data.datasets[1].backgroundColor = barBackgrounds;
        historicalInventoryChartInstance.data.datasets[1].borderColor = barBorders;
        historicalInventoryChartInstance.data.datasets[1].borderWidth = 2;
        // Store orderStatusData for tooltip access
        historicalInventoryChartInstance.orderStatusData = combinedOrderVisualStatus;
        historicalInventoryChartInstance.update();
        historicalInventoryChartInstance.resize();
      } else if (window.Chart && historicalInventoryCanvas.getContext) {
        historicalInventoryChartInstance = new Chart(historicalInventoryCanvas.getContext("2d"), {
          type: "bar",
          data: {
            labels: combinedLabels,
            datasets: [
              {
                type: "line",
                label: "on-hand inventory",
                data: combinedOnHandData,
                borderColor: "#e74c3c",
                backgroundColor: "transparent",
                borderWidth: 2,
                pointRadius: 4,
                pointBackgroundColor: "#e74c3c",
                pointBorderColor: "#ffffff",
                pointBorderWidth: 1,
                tension: 0,
                order: 1, // Show line chart on top (lower order number = higher z-index)
              },
              {
                type: "bar",
                label: "order",
                data: combinedOrderData,
                backgroundColor: combinedOrderVisualStatus.map((status) =>
                  status.arrived ? "rgba(46, 204, 113, 0.6)" : "transparent"
                ),
                borderColor: combinedOrderVisualStatus.map(() => "rgba(46, 204, 113, 0.8)"),
                borderWidth: 2,
                borderSkipped: false,
                order: 2, // Show bar chart below line (higher order number = lower z-index)
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
              mode: "index",
              intersect: false,
            },
            scales: {
              y: {
                beginAtZero: true,
                title: {
                  display: true,
                  text: "Units",
                },
                ticks: {
                  callback: (value) => formatNumber(value),
                },
                grid: {
                  color: "rgba(102, 126, 234, 0.15)",
                },
              },
              x: {
                grid: {
                  color: "rgba(102, 126, 234, 0.08)",
                },
              },
            },
            plugins: {
              legend: {
                display: true,
                position: "bottom",
                labels: {
                  usePointStyle: true,
                  generateLabels: (chart) => {
                    const original = Chart.defaults.plugins.legend.labels.generateLabels(chart);
                    const labels = [];
                    // First: on-hand inventory (line chart, red)
                    if (original[0]) {
                      const lineLabel = { ...original[0] };
                      lineLabel.fillStyle = "transparent";
                      lineLabel.strokeStyle = "#e74c3c";
                      lineLabel.lineWidth = 2;
                      lineLabel.pointStyle = "line";
                      labels.push(lineLabel);
                    }
                    // Second: order (received) - green filled
                    if (original[1]) {
                      const receivedLabel = { ...original[1] };
                      receivedLabel.fillStyle = "rgba(46, 204, 113, 0.6)";
                      receivedLabel.strokeStyle = "rgba(46, 204, 113, 0.8)";
                      receivedLabel.lineWidth = 2;
                      receivedLabel.pointStyle = "rect";
                      receivedLabel.text = "order (received)";
                      labels.push(receivedLabel);
                    }
                    // Third: order (in-transit) - green border, transparent fill
                    if (original[1]) {
                      const inTransitLabel = { ...original[1] };
                      inTransitLabel.fillStyle = "transparent";
                      inTransitLabel.strokeStyle = "rgba(46, 204, 113, 0.8)";
                      inTransitLabel.lineWidth = 2;
                      inTransitLabel.pointStyle = "rect";
                      inTransitLabel.text = "order (in-transit)";
                      inTransitLabel.datasetIndex = -1;
                      labels.push(inTransitLabel);
                    }
                    return labels;
                  },
                },
              },
              tooltip: {
                callbacks: {
                  label: (ctx) => {
                    const label = ctx.dataset.label || "";
                    const value = formatNumber(ctx.parsed.y);
                    if (ctx.datasetIndex === 1 && ctx.parsed.y > 0) {
                      const orderStatusData = ctx.chart.orderStatusData || [];
                      const status = orderStatusData[ctx.dataIndex];
                      if (status) {
                        if (status.arrived && status.arrivalWeek !== null) {
                          const dateLabel = getDateForPeriod(status.arrivalWeek);
                          if (dateLabel) {
                            return `${label}: ${value} (received ${dateLabel})`;
                          }
                          return `${label}: ${value} (received)`;
                        }
                      }
                      return `${label}: ${value} (in-transit)`;
                    }
                    return `${label}: ${value}`;
                  },
                },
              },
            },
          },
        });
        // Store orderStatusData for tooltip access
        historicalInventoryChartInstance.orderStatusData = combinedOrderVisualStatus;
      }
    }

    function ensureCanvasDimensions(canvas) {
      if (!canvas) return;
      const desired = 300;
      const width = canvas.clientWidth || (canvas.parentElement ? canvas.parentElement.clientWidth : 480);
      canvas.height = desired;
      canvas.style.height = `${desired}px`;
      canvas.style.maxHeight = `${desired}px`;
      if (width > 0) {
        canvas.width = width;
        canvas.style.width = "100%";
      }
    }

    function buildLineChartOptions({ yLabel, tooltipLabel }) {
      return {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: true,
            position: "top",
          },
          tooltip: {
            callbacks: {
              label: tooltipLabel,
            },
          },
        },
        interaction: {
          intersect: false,
          mode: "index",
        },
        scales: {
          x: {
            grid: {
              display: false,
            },
          },
          y: {
            beginAtZero: true,
            title: {
              display: Boolean(yLabel),
              text: yLabel || "",
            },
          },
        },
      };
    }

    async function apiRequest(path, options = {}) {
      const userId = localStorage.getItem('user_id');
      
      // Create AbortController for timeout if AbortSignal.timeout is not available
      let abortController = null;
      let timeoutId = null;
      
      if (typeof AbortSignal !== 'undefined' && AbortSignal.timeout) {
        // Modern browsers support AbortSignal.timeout
        try {
          abortController = { signal: AbortSignal.timeout(30000) };
        } catch (e) {
          // Fallback if timeout not supported
          abortController = new AbortController();
          timeoutId = setTimeout(() => abortController.abort(), 30000);
        }
      } else {
        // Fallback for older browsers
        abortController = new AbortController();
        timeoutId = setTimeout(() => abortController.abort(), 30000);
      }
      
      const fetchOptions = {
        method: "GET",
        ...options,
        headers: {
          "Content-Type": "application/json",
          "X-User-ID": userId || "anonymous",
          ...(options.headers || {}),
        },
        signal: abortController.signal,
      };
      
      try {
        const response = await fetch(path, fetchOptions);
        if (timeoutId) clearTimeout(timeoutId);
        
        if (!response.ok) {
          const text = await response.text();
          throw new Error(text || response.statusText);
        }
        return response.json();
      } catch (err) {
        if (timeoutId) clearTimeout(timeoutId);
        
        // Handle timeout and network errors
        if (err.name === 'TimeoutError' || err.name === 'AbortError' || err.message === 'The user aborted a request.') {
          throw new Error('Request timeout - server may be overloaded');
        }
        if (err.name === 'TypeError' && err.message.includes('fetch')) {
          throw new Error('Network error - check connection');
        }
        throw err;
      }
    }

    function formatCurrency(value) {
      const num = Number(value);
      if (!Number.isFinite(num)) return "$0.00";
      return `$${num.toFixed(2)}`;
    }

    function formatUnitCurrency(value) {
      return formatCurrency(value);
    }

    function formatNumber(value, decimals = 0) {
      const num = Number(value);
      if (!Number.isFinite(num)) return "--";
      return num.toLocaleString(undefined, {
        minimumFractionDigits: decimals,
        maximumFractionDigits: decimals,
      });
    }

    function tryExtractString(value) {
      if (value == null) return "";
      if (typeof value === "string") return value;
      if (typeof value === "object") return JSON.stringify(value);
      return String(value);
    }

    function escapeHtml(str) {
      return String(str)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }
</script>
</body>
</html>
